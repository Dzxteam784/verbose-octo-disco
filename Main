if not game:IsLoaded() then repeat task.wait() until game:IsLoaded() end

if not (game.PlaceId == 104715542330896 or game.PlaceId == 97556409405464) then return end

local require = require or getfenv().require
local cloneref = cloneref or function(f) return f end
local Net = require(cloneref(game:GetService('ReplicatedStorage').Modules.Core.Net))
local getupvalue = getupvalue or debug.getupvalue
local setconstant = setconstant or debug.setconstant

do
    local func2 = getupvalue(Net.send, 2)
    setconstant(func2, 1, "...")
    setconstant(func2, 3, "...")
    setconstant(func2, 4, "...")
    setconstant(func2, 9, "...")
    local func = getupvalue(Net.get, 2)
    setconstant(func, 1, "...")
    setconstant(func, 3, "...")
    setconstant(func, 4, "...")
    setconstant(func, 9, "...")

    local real_getfenv = getfenv
    getfenv = function(level)
        if level == 6 then
            local original_env = real_getfenv(6)
            return setmetatable({}, {
                __index = function(self, key)
                    if key == "getgenv" or key == "identifyexecutor" then
                        return nil
                    end
                    return original_env and original_env[key]
                end,
                __newindex = function(self, key, value)
                    if original_env then
                        original_env[key] = value
                    end
                end
            })
        end
        return real_getfenv(level)
    end
end




local WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/main/dist/main.lua"))()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Data = require(ReplicatedStorage.Modules.Core.Data)
local pls = game.Players.LocalPlayer
local Window = WindUI:CreateWindow({
    Title = "DZHUB  | v-1.0 Test üî´",
    Author = "by danzaza ",
    
    BackgroundImageTransparency = 0.25,
    HideSearchBar = false,
    Folder = "Dzhub",
  
    SideBarWidth = 200,
    
    KeySystem = {
        Note = "Get the key to get full access to the script",
        SaveKey = false,
        Key = { "1234", "test" },  
         Note = "Key System Dzhub.",
          URL = "https://github.com/Footagesus/WindUI",
          Thumbnail = {
              Image = "rbxassetid://134656917989517",
             
          },
    },
    
    OpenButton = {
        Title = "DZHUB | v-1.0", -- can be changed
        CornerRadius = UDim.new(1,0), -- fully rounded
        StrokeThickness = 3, -- removing outline
        Enabled = true, -- enable or disable openbutton
        Draggable = false,
        OnlyMobile = false,
        
        Color = ColorSequence.new( -- gradient
            Color3.fromHex("#30FF6A"), 
            Color3.fromHex("#e7ff2f")
        )
    }
}) 
-- */ Other Functions /* --
local function parseJSON(luau_table, indent, level, visited)
    indent = indent or 2
    level = level or 0
    visited = visited or {}
    
    local currentIndent = string.rep(" ", level * indent)
    local nextIndent = string.rep(" ", (level + 1) * indent)
    
    if luau_table == nil then
        return "null"
    end
    
    local dataType = type(luau_table)
    
    if dataType == "table" then
        if visited[luau_table] then
            return "\"[Circular Reference]\""
        end
        
        visited[luau_table] = true
        
        local isArray = true
        local maxIndex = 0
        
        for k, _ in pairs(luau_table) do
            if type(k) == "number" and k > maxIndex then
                maxIndex = k
            end
            if type(k) ~= "number" or k <= 0 or math.floor(k) ~= k then
                isArray = false
                break
            end
        end
        
        local count = 0
        for _ in pairs(luau_table) do
            count = count + 1
        end
        if count ~= maxIndex and isArray then
            isArray = false
        end
        
        if count == 0 then
            return "{}"
        end
        
        if isArray then
            if count == 0 then
                return "[]"
            end
            
            local result = "[\n"
            
            for i = 1, maxIndex do
                result = result .. nextIndent .. parseJSON(luau_table[i], indent, level + 1, visited)
                if i < maxIndex then
                    result = result .. ","
                end
                result = result .. "\n"
            end
            
            result = result .. currentIndent .. "]"
            return result
        else
            local result = "{\n"
            local first = true
            
            local keys = {}
            for k in pairs(luau_table) do
                table.insert(keys, k)
            end
            table.sort(keys, function(a, b)
                if type(a) == type(b) then
                    return tostring(a) < tostring(b)
                else
                    return type(a) < type(b)
                end
            end)
            
            for _, k in ipairs(keys) do
                local v = luau_table[k]
                if not first then
                    result = result .. ",\n"
                else
                    first = false
                end
                
                if type(k) == "string" then
                    result = result .. nextIndent .. "\"" .. k .. "\": "
                else
                    result = result .. nextIndent .. "\"" .. tostring(k) .. "\": "
                end
                
                result = result .. parseJSON(v, indent, level + 1, visited)
            end
            
            result = result .. "\n" .. currentIndent .. "}"
            return result
        end
    elseif dataType == "string" then
        local escaped = luau_table:gsub("\\", "\\\\")
        escaped = escaped:gsub("\"", "\\\"")
        escaped = escaped:gsub("\n", "\\n")
        escaped = escaped:gsub("\r", "\\r")
        escaped = escaped:gsub("\t", "\\t")
        
        return "\"" .. escaped .. "\""
    elseif dataType == "number" then
        return tostring(luau_table)
    elseif dataType == "boolean" then
        return luau_table and "true" or "false"
    elseif dataType == "function" then
        return "\"function\""
    else
        return "\"" .. dataType .. "\""
    end
end

local function tableToClipboard(luau_table, indent)
    indent = indent or 4
    local jsonString = parseJSON(luau_table, indent)
    setclipboard(jsonString)
    return jsonString
end


local replicated = game:GetService("ReplicatedStorage")
local CrateController = require(replicated.Modules.Game.CrateSystem.Crate)
local Players = game:GetService("Players")
local CharModule = require(replicated.Modules.Core.Char)
local Client = Players.LocalPlayer
local PlayerGui = Client.PlayerGui
local Character = Client.Character or Client.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")


local replicated = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local PathfindingService = game:GetService("PathfindingService")
local vim = game:GetService("VirtualInputManager")
local teleport = game:GetService('TeleportService')
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local Debris = game:GetService("Debris")
local UserInputService = game:GetService("UserInputService")
local CurrentCamera = workspace.CurrentCamera

local Client = Players.LocalPlayer
local Character = Client.Character or Client.CharacterAdded:Wait()
local UserId = Client.UserId
local PlayerGui = Client.PlayerGui
local Humanoid = Character:WaitForChild("Humanoid")
local RootPart = Character:WaitForChild("HumanoidRootPart")
local Backpack = Client:WaitForChild("Backpack")

Client.CharacterAdded:Connect(function(newCharacter)
	Character = newCharacter
	Humanoid = Character:WaitForChild('Humanoid')
	RootPart = Character:WaitForChild('HumanoidRootPart')
	Backpack = Client:WaitForChild("Backpack")
end)	

local insert = table.insert
local CFrame_new = CFrame.new
local Vector_new = Vector3.new
local TwoD_new = Vector2.new
local UDim2_new = UDim2.new
local waits = task.wait
local get = ipairs
local getn = pairs
local word_find = string.find
local create = Instance.new
local stop = task.cancel
local this_is_string = tostring
local this_is_number = tonumber
local un = unpack
local randomb = math.random
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local SendRemote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Send")
local Camera = workspace.CurrentCamera



local ServerFunc,func,functionb = {},{},{}; 
ServerFunc.__index = ServerFunc 
func.__index = func


local function c() 
    return getgenv()
end

function ServerFunc:Action(...)
	local args = {...}
	return Net.send(un(args))
end




local droppedItems = workspace:FindFirstChild("DroppedItems")
local Puddles = workspace:FindFirstChild("Map")and workspace.Map:FindFirstChild("Tiles")and workspace.Map.Tiles:FindFirstChild("BurgerPlaceTile")and workspace.Map.Tiles.BurgerPlaceTile:FindFirstChild("BurgerPlace")and workspace.Map.Tiles.BurgerPlaceTile.BurgerPlace:FindFirstChild("Interior")and workspace.Map.Tiles.BurgerPlaceTile.BurgerPlace.Interior:FindFirstChild("Puddles")
local SteakHouseBro = workspace:FindFirstChild("Map")and workspace.Map:FindFirstChild("Tiles")and workspace.Map.Tiles:FindFirstChild("ShoppingTile")and workspace.Map.Tiles.ShoppingTile:FindFirstChild("SteakHouse")
local DataModule = require(replicated.Modules.Core.Data)
local ItemUtilsModule = require(replicated.Modules.Game.Inventory.ItemUtils)
local CrateController = require(replicated.Modules.Game.CrateSystem.Crate)
local CharModule = require(replicated.Modules.Core.Char)
local throwable = replicated.Items.throwable





local Staminacolor = Client.PlayerGui.TopRightHud.Holder.StaminaBar.Fill.Normal
Staminacolor.Color = ColorSequence.new(Color3.fromRGB(107, 50, 124))
local SilentAim = false



-- ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á GUI ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
local guiPosition = LocalPlayer.PlayerGui.SelectPlayer.ChoosePlayerHolder.AbsolutePosition
local guiSize = LocalPlayer.PlayerGui.SelectPlayer.ChoosePlayerHolder.AbsoluteSize

-- FOV Circle
local fovCircle = Drawing.new("Circle")
fovCircle.Radius = 200
fovCircle.Color = Color3.new(255,255,255)
fovCircle.Thickness = 2
fovCircle.Filled = false
fovCircle.Visible = false
fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

-- ‡∏´‡∏≤‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÉ‡∏ô FOV
local function getClosestTargetInFOV()
    local closestDistance = math.huge
    local closestHumanoidPart = nil

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local head = player.Character:FindFirstChild("Head")
            if head then
                local screenPos, onScreen = Camera:WorldToViewportPoint(head.Position)
                if onScreen then
                    local distToCenter = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)).Magnitude
                    if distToCenter <= fovCircle.Radius and distToCenter < closestDistance then
                        closestDistance = distToCenter
                        closestHumanoidPart = head
                    end
                end
            end
        end
    end

    return closestHumanoidPart
end


-- ‡∏™‡∏£‡πâ‡∏≤‡∏á Tracer
local function createTracer(startPos, endPos, hitPlayer)
    local tracer = Instance.new("Part")
    tracer.Anchored = true
    tracer.CanCollide = false
    tracer.Material = Enum.Material.Neon
    tracer.Color = hitPlayer and Color3.fromHSV((tick() % 5) / 5, 1, 1)
    tracer.Size = Vector3.new(0.08, 0.08, (startPos - endPos).Magnitude)
    tracer.CFrame = CFrame.new((startPos + endPos)/2, endPos)
    tracer.Parent = workspace
    game:GetService("Debris"):AddItem(tracer, 1.5)
end




-- ESP Line
local line = Drawing.new("Line")
line.Color = Color3.new(1,0,0)
line.Thickness = 2
line.Transparency = 1


  

-- Update FOV + ESP
RunService.RenderStepped:Connect(function()
    fovCircle.Radius = c().Radius
    fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

    -- ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á GUI
    guiPosition = LocalPlayer.PlayerGui.SelectPlayer.ChoosePlayerHolder.AbsolutePosition
    guiSize = LocalPlayer.PlayerGui.SelectPlayer.ChoosePlayerHolder.AbsoluteSize
    
    -- ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏∏‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏Ç‡∏≠‡∏á GUI ‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡∏ï‡πà‡∏≥‡∏•‡∏á
    local guiCenter = Vector2.new(
        guiPosition.X + guiSize.X / 2,
        guiPosition.Y + guiSize.Y + 58  -- ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡πà‡∏≤ Y ‡πÉ‡∏´‡πâ‡∏ï‡πà‡∏≥‡∏•‡∏á 50 pixels ‡∏à‡∏≤‡∏Å‡∏Ç‡∏≠‡∏ö‡∏•‡πà‡∏≤‡∏á‡∏Ç‡∏≠‡∏á GUI
    )

    local target = getClosestTargetInFOV()
  
    
    if target and SilentAim then
        local endPos = Camera:WorldToViewportPoint(target.Position)

        -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å GUI ‡πÑ‡∏õ‡∏´‡∏≤‡∏®‡∏±‡∏ï‡∏£‡∏π
        line.From = guiCenter
        line.To = Vector2.new(endPos.X, endPos.Y)
        line.Visible = true
    else
        line.Visible = false
    end
end)

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏î‡∏±‡∏Å‡∏´‡∏ô‡πâ‡∏≤
local function getPredictedPosition(target)
    local root = target.Parent:FindFirstChild("HumanoidRootPart")
    if not root then return target.Position end

    local velocity = root.Velocity or Vector3.new(0,1,0)
    local ping = 0.27 -- ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏ß‡∏•‡∏≤ lag/ping (‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏£‡∏¥‡∏á)
    local predictedPos = target.Position + velocity * ping
    return predictedPos
end



local oldSendFire
oldSendFire = hookfunction(SendRemote.FireServer, function(self, ...)
    local args = {...}

    if type(args[2]) == "string" and args[2]:lower():find("shoot") then
        local targetHead = getClosestTargetInFOV()
        if targetHead and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local predictedPos = getPredictedPosition(targetHead)
            
            args[4] = CFrame.new(math.huge,math.huge,math.huge)
            args[5] = {
                {
                    {
                        Instance = targetHead,
                        Position = predictedPos,
                        Normal = (predictedPos - LocalPlayer.Character.Head.Position).Unit,
                        Material = Enum.Material.Plastic,
                        Distance = (predictedPos - LocalPlayer.Character.Head.Position).Magnitude
                    },
                    {
                        Instance = targetHead,
                        Position = predictedPos,
                        Normal = (predictedPos - LocalPlayer.Character.Head.Position).Unit,
                        Material = Enum.Material.Plastic,
                        Distance = (predictedPos - LocalPlayer.Character.Head.Position).Magnitude
                    }
                }
            }

            createTracer(LocalPlayer.Character.HumanoidRootPart.Position, predictedPos, true)
        end
    end

    return oldSendFire(self, unpack(args))
end)









local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- ESP Settings
local ESPSettings = {
    Box3DEnabled = false,
    SkeletonEnabled = false,
    NameEnabled = false,
    DistanceEnabled = false,
    HealthEnabled = false,
    EspViewitems = false,
    BoxColor = Color3.fromRGB(255,255,255),
    LockColor = Color3.fromRGB(255,0,0),
    NameColor = Color3.fromRGB(255,255,255),
    HealthColor = Color3.fromRGB(0,255,0),
    SkeletonColor = Color3.fromRGB(247, 241, 141)
}

-- Store Drawing objects
local ESPObjects = {}

-- Remove ESP when player leaves
local function removeESP(player)
    if ESPObjects[player] then
        for _, obj in pairs(ESPObjects[player]) do
            if typeof(obj) == "table" then
                for _, v in ipairs(obj) do v:Remove() end
            else
                obj:Remove()
            end
        end
        ESPObjects[player] = nil
    end
end

-- Create ESP for a player
local function createESP(player)
    -- Box 3D (12 lines)
    local box3D = {}
    for i = 1, 12 do
        local line = Drawing.new("Line")
        line.Thickness = 1
        line.Color = ESPSettings.BoxColor
        line.Visible = false
        table.insert(box3D, line)
    end

    -- Skeleton (15 lines)
    local skeleton = {}
    for i = 1, 15 do
        local line = Drawing.new("Line")
        line.Thickness = 1
        line.Color = ESPSettings.SkeletonColor
        line.Visible = false
        table.insert(skeleton, line)
    end

    -- Name
    local nameText = Drawing.new("Text")
    nameText.Size = 10
    nameText.Color = ESPSettings.NameColor
    nameText.Center = true
    nameText.Outline = true
    nameText.Visible = false

    -- Distance
    local distanceText = Drawing.new("Text")
    distanceText.Size = 7
    distanceText.Center = true
    distanceText.Outline = true
    distanceText.Visible = false

    -- Health
    local healthText = Drawing.new("Text")
    healthText.Size = 8
    healthText.Color = ESPSettings.HealthColor
    healthText.Center = true
    healthText.Outline = true
    healthText.Visible = false

    ESPObjects[player] = {
        Box3D = box3D,
        Skeleton = skeleton,
        Name = nameText,
        Distance = distanceText,
        Health = healthText
    }
end

-- Create ESP for existing players
for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        createESP(player)
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        createESP(player)
    end
end)

Players.PlayerRemoving:Connect(function(player)
    removeESP(player)
end)


-- Function to get closest target
local function getClosestTargetInFOV()
    local closestDistance = math.huge
    local closestTarget = nil
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local part = player.Character:FindFirstChild("Head") or player.Character:FindFirstChild("HumanoidRootPart")
            if part then
                local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local distToCenter = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)).Magnitude
                    if distToCenter < closestDistance then
                        closestDistance = distToCenter
                        closestTarget = part
                    end
                end
            end
        end
    end
    return closestTarget
end

-- üîπ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï Box 3D
local function updateBox3D(player, obj)
    local char = player.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return end

    local hrp = char.HumanoidRootPart
    local cf, size = hrp.CFrame, Vector3.new(4, 7, 4)

    local corners = {
        Vector3.new(-size.X, -size.Y, -size.Z) / 2,
        Vector3.new( size.X, -size.Y, -size.Z) / 2,
        Vector3.new( size.X,  size.Y, -size.Z) / 2,
        Vector3.new(-size.X,  size.Y, -size.Z) / 2,
        Vector3.new(-size.X, -size.Y,  size.Z) / 2,
        Vector3.new( size.X, -size.Y,  size.Z) / 2,
        Vector3.new( size.X,  size.Y,  size.Z) / 2,
        Vector3.new(-size.X,  size.Y,  size.Z) / 2,
    }

    local screenCorners, visCount = {}, 0
    for i, v in ipairs(corners) do
        local worldPos = (cf * CFrame.new(v)).Position
        local screenPos, onScreen = Camera:WorldToViewportPoint(worldPos)
        screenCorners[i] = Vector2.new(screenPos.X, screenPos.Y)
        if onScreen then visCount += 1 end
    end

    local edges = {
        {1,2},{2,3},{3,4},{4,1},
        {5,6},{6,7},{7,8},{8,5},
        {1,5},{2,6},{3,7},{4,8},
    }

    local lines = obj.Box3D
    if ESPSettings.Box3DEnabled and visCount == 8 then
        local target = getClosestTargetInFOV()
        local color = (target and target.Parent == char) and ESPSettings.LockColor or ESPSettings.BoxColor

        for i, e in ipairs(edges) do
            local line = lines[i]
            line.From = screenCorners[e[1]]
            line.To   = screenCorners[e[2]]
            line.Color = color
            line.Visible = true
        end
    else
        for _, l in ipairs(lines) do l.Visible = false end
    end
end


local ItemESPObjects = {}

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á ESP ‡πÉ‡∏´‡πâ‡∏Ç‡∏≠‡∏á‡∏ï‡∏Å
local function createItemESP(item)
    if not item:IsA("BasePart") and not item:FindFirstChildWhichIsA("BasePart") then return end

    local box3D = {}
    for i = 1, 12 do
        local line = Drawing.new("Line")
        line.Thickness = 1
        line.Color = ESPSettings.BoxColor
        line.Visible = false
        table.insert(box3D, line)
    end

    local nameText = Drawing.new("Text")
    nameText.Size = 9
    nameText.Color = Color3.fromRGB(255, 255, 0)
    nameText.Center = true
    nameText.Outline = true
    nameText.Visible = false

    ItemESPObjects[item] = {
        Box3D = box3D,
        Name = nameText
    }
end

-- ‡∏•‡∏ö ESP ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ç‡∏≠‡∏á‡∏´‡∏≤‡∏¢‡πÑ‡∏õ
local function removeItemESP(item)
    if ItemESPObjects[item] then
        for _, obj in pairs(ItemESPObjects[item]) do
            if typeof(obj) == "table" then
                for _, v in ipairs(obj) do v:Remove() end
            else
                obj:Remove()
            end
        end
        ItemESPObjects[item] = nil
    end
end

-- ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Ç‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á
if droppedItems then
    droppedItems.ChildAdded:Connect(function(item)
        task.wait(0.2)
        createItemESP(item)
    end)

    droppedItems.ChildRemoved:Connect(removeItemESP)

    for _, item in pairs(droppedItems:GetChildren()) do
        createItemESP(item)
    end
end


-- Update ESP
RunService.RenderStepped:Connect(function()
    for player, obj in pairs(ESPObjects) do
        local char = player.Character
        if char and char:FindFirstChild("HumanoidRootPart") and char:FindFirstChild("Humanoid") then
            local root = char.HumanoidRootPart
            local head = char:FindFirstChild("Head")
            local humanoid = char.Humanoid

            local screenHead, headOnScreen = Camera:WorldToViewportPoint(head.Position)
            local distance = (root.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude

            if headOnScreen then
                updateBox3D(player, obj)

                -- Name
                if ESPSettings.NameEnabled then
                    obj.Name.Text = player.Name
                    obj.Name.Position = Vector2.new(screenHead.X, screenHead.Y - 10)
                    obj.Name.Visible = true
                else
                    obj.Name.Visible = false
                end

                -- Distance
                if ESPSettings.DistanceEnabled then
                    obj.Distance.Text = string.format("%.0f", distance).."m"
                    obj.Distance.Position = Vector2.new(screenHead.X, screenHead.Y + 20)
                    obj.Distance.Visible = true
                else
                    obj.Distance.Visible = false
                end

                
                if ESPSettings.HealthEnabled then
                    obj.Health.Text = string.format("[ %d HP ]", math.floor(humanoid.Health))
                    obj.Health.Position = Vector2.new(screenHead.X, screenHead.Y + 35)
                    obj.Health.Visible = true
                else
                    obj.Health.Visible = false
                end
            else
                updateBox3D(player, obj)
                obj.Name.Visible = false
                obj.Distance.Visible = false
                obj.Health.Visible = false
            end
        else
            updateBox3D(player, obj)
            obj.Name.Visible = false
            obj.Distance.Visible = false
            obj.Health.Visible = false
        end
    end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and ESPObjects[player] then
            local char = player.Character
            local esp = ESPObjects[player]
            if char and char:FindFirstChild("Head") and char:FindFirstChild("HumanoidRootPart") then
                local hrp = char.HumanoidRootPart
                local head = char.Head

                -- Skeleton rendering
                if ESPSettings.SkeletonEnabled then
                    local bones = {
                        {"Head", "UpperTorso"},
                        {"UpperTorso", "LowerTorso"},
                        {"UpperTorso", "LeftUpperArm"},
                        {"UpperTorso", "RightUpperArm"},
                        {"LeftUpperArm", "LeftLowerArm"},
                        {"RightUpperArm", "RightLowerArm"},
                        {"LeftLowerArm", "LeftHand"},
                        {"RightLowerArm", "RightHand"},
                        {"LowerTorso", "LeftUpperLeg"},
                        {"LowerTorso", "RightUpperLeg"},
                        {"LeftUpperLeg", "LeftLowerLeg"},
                        {"RightUpperLeg", "RightLowerLeg"},
                        {"LeftLowerLeg", "LeftFoot"},
                        {"RightLowerLeg", "RightFoot"},
                        {"UpperTorso", "Head"}
                    }

                    for i, pair in ipairs(bones) do
                        local part1 = char:FindFirstChild(pair[1])
                        local part2 = char:FindFirstChild(pair[2])
                        local line = esp.Skeleton[i]
                        if part1 and part2 then
                            local pos1, vis1 = Camera:WorldToViewportPoint(part1.Position)
                            local pos2, vis2 = Camera:WorldToViewportPoint(part2.Position)
                            if vis1 and vis2 then
                                line.From = Vector2.new(pos1.X, pos1.Y)
                                line.To = Vector2.new(pos2.X, pos2.Y)
                                line.Color = ESPSettings.SkeletonColor
                                line.Visible = true
                            else
                                line.Visible = false
                            end
                        else
                            line.Visible = false
                        end
                    end
                end
            else
                -- Hide all lines if no character
                if esp.Skeleton then
                    for _, line in pairs(esp.Skeleton) do
                        line.Visible = false
                    end
                end
            end
        end
    end
    
      if not droppedItems then return end
for item, obj in pairs(ItemESPObjects) do
    if item and item.Parent then
        if item.Name == "Money" then
            -- ‡∏ã‡πà‡∏≠‡∏ô‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏Å‡∏±‡∏ö‡∏ä‡∏∑‡πà‡∏≠
            for _, l in ipairs(obj.Box3D) do l.Visible = false end
            obj.Name.Visible = false
            continue -- ‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏õ item ‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
        end
            local basePart = item:IsA("BasePart") and item or item:FindFirstChildWhichIsA("BasePart")
            if not basePart then continue end

            local cf, size = basePart.CFrame, Vector3.new(1, 0.8, 1.5)
            local corners = {
        Vector3.new(-size.X, -size.Y, -size.Z) / 2,
        Vector3.new( size.X, -size.Y, -size.Z) / 2,
        Vector3.new( size.X,  size.Y, -size.Z) / 2,
        Vector3.new(-size.X,  size.Y, -size.Z) / 2,
        Vector3.new(-size.X, -size.Y,  size.Z) / 2,
        Vector3.new( size.X, -size.Y,  size.Z) / 2,
        Vector3.new( size.X,  size.Y,  size.Z) / 2,
        Vector3.new(-size.X,  size.Y,  size.Z) / 2,
            }

            local screenCorners, visCount = {}, 0
            for i, v in ipairs(corners) do
                local worldPos = (cf * CFrame.new(v)).Position
                local screenPos, onScreen = Camera:WorldToViewportPoint(worldPos)
                screenCorners[i] = Vector2.new(screenPos.X, screenPos.Y)
                if onScreen then visCount += 1 end
            end

            local edges = {
        {1,2},{2,3},{3,4},{4,1},
        {5,6},{6,7},{7,8},{8,5},
        {1,5},{2,6},{3,7},{4,8},
             }

            local lines = obj.Box3D
            if visCount == 8 and ESPSettings.EspViewitems then
                for i, e in ipairs(edges) do
                    local line = lines[i]
                    line.From = screenCorners[e[1]]
                    line.To = screenCorners[e[2]]
                    line.Visible = true
                end

                local screenPos, onScreen = Camera:WorldToViewportPoint(cf.Position)
                if onScreen and ESPSettings.EspViewitems then
                    obj.Name.Text = item.Name
                    obj.Name.Position = Vector2.new(screenPos.X, screenPos.Y - 10)
                    obj.Name.Visible = true
                else
                    obj.Name.Visible = false
                end
            else
                for _, l in ipairs(lines) do l.Visible = false end
                obj.Name.Visible = false
            end
        else
            removeItemESP(item)
        end
    end
    
end)







local Staminacolor = Client.PlayerGui.TopRightHud.Holder.StaminaBar.Fill.Normal
local isInCombat = Client:GetAttribute("IsInCombat")
local plr = game:GetService("Players").LocalPlayer
local DROP_Y = -50
local HEALTH_MIN = 21
local HEALTH_RECOVER = 30
local isDropping = false 
local antiKillEnabled = false
local RunService = game:GetService("RunService")
local camera = workspace.CurrentCamera
local cameraLockConn

local function lockCamera()
    local lockedPosition = camera.CFrame.Position
    if cameraLockConn then
        cameraLockConn:Disconnect()
        cameraLockConn = nil
    end

    cameraLockConn = RunService.RenderStepped:Connect(function()
        local lookVector = camera.CFrame.LookVector
        camera.CFrame = CFrame.new(lockedPosition, lockedPosition + lookVector)
    end)
end

local function unlockCamera()
    if cameraLockConn then
        cameraLockConn:Disconnect()
        cameraLockConn = nil
    end
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ character
local function setupCharacter(char)
    local humanoid = char:WaitForChild("Humanoid")
    local rootPart = char:WaitForChild("HumanoidRootPart")

    local function startDrop()
        if not antiKillEnabled then return end
        if isDropping then return end
        isDropping = true
      --  lockCamera()
        

        local fixedPos = rootPart.Position  
        fixedPos = Vector3.new(fixedPos.X, fixedPos.Y + DROP_Y, fixedPos.Z)  

        local t = 0
        while isDropping do  
            if humanoid.Health >= HEALTH_RECOVER or humanoid.Health <= 0 then
                isDropping = false
               -- unlockCamera()

                if  isInCombat then
                    print("hee")
                else
                    task.wait(0.6)
                    Net.send('request_respawn')
                end
                break
            end  

            t += 50
            local swingX = math.sin(t * 3000) * 6
            local swingZ = math.cos(t * 3000) * 8
            local newPos = fixedPos + Vector3.new(swingX, math.sin(t * 2) * 2, swingZ)

            rootPart.CFrame = CFrame.new(newPos)
            task.wait() 
        end
    end

    humanoid.HealthChanged:Connect(function(hp)
        if hp < HEALTH_MIN and hp > 0 then
            startDrop()
        end
    end)
end

-- ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ï‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°
if plr.Character then
    setupCharacter(plr.Character)
end

-- ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà respawn
plr.CharacterAdded:Connect(setupCharacter)







local Snap = false
local Snapdrop = -100
local isDropping = false
local effectIntensity = 50 -- ‡∏Ñ‡πà‡∏≤ Slider ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
local fixedPos = nil -- ‡∏à‡∏∞‡πÄ‡∏Å‡πá‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Ñ‡πâ‡∏≤‡∏á‡∏ô‡∏¥‡πà‡∏á

local plr = Players.LocalPlayer

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ character
local function setupCharacter(char)
    local rootPart = char:WaitForChild("HumanoidRootPart")

    local function startDrop()
        if not Snap then return end
        if isDropping then return end
        isDropping = true

        -- ‡πÄ‡∏Å‡πá‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Ñ‡πâ‡∏≤‡∏á‡∏ô‡∏¥‡πà‡∏á‡∏ï‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°
        local pos = rootPart.Position
        fixedPos = Vector3.new(pos.X, pos.Y + Snapdrop * (effectIntensity / 100), pos.Z)

        -- ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡∏Ñ‡πâ‡∏≤‡∏á‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
        while Snap and isDropping do
            if rootPart and fixedPos then
                rootPart.CFrame = CFrame.new(fixedPos)
            end
            task.wait()
        end

        isDropping = false
    end

    -- ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å startDrop ‡πÑ‡∏î‡πâ‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà Toggle ‡∏´‡∏£‡∏∑‡∏≠ Slider ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô
    plr:GetAttributeChangedSignal("SnapTrigger"):Connect(startDrop)
end

if plr.Character then
    setupCharacter(plr.Character)
end
plr.CharacterAdded:Connect(setupCharacter)



func['AutoPickItem'] = function()
    while waits() do 
        if c().AutoPickItem then 
            for i,v in get(droppedItems:GetChildren()) do 
                if not v:GetAttribute('Locked') then
                    local dist = ServerFunc:dist(v:FindFirstChild('PickUpZone'))
                    if dist < c().Stud_PickItem then 
                        Net.get("pickup_dropped_item",v)
                    end 
                end
            end
        end
    end
end

local droppedItems = workspace:WaitForChild("DroppedItems")
local pickUpZoneEnabled = false -- ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ toggle

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î PickUpZone
local function resizePickUpZone(model)
    if model:IsA("Model") then
        for _, child in ipairs(model:GetChildren()) do
            if child:IsA("Part") and child.Name == "PickUpZone" then
                child.Size = pickUpZoneEnabled and Vector3.new(15, 15, 15) or Vector3.new(5,3,3)
            end
        end
    end
end

-- ‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î PickUpZone ‡∏Ç‡∏≠‡∏á‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
local function resizeAll()
    for _, model in ipairs(droppedItems:GetChildren()) do
        resizePickUpZone(model)
    end
end

-- ‡∏ü‡∏±‡∏á‡πÄ‡∏´‡∏ï‡∏∏‡∏Å‡∏≤‡∏£‡∏ì‡πå‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡πÇ‡∏°‡πÄ‡∏î‡∏•‡πÉ‡∏´‡∏°‡πà‡∏ñ‡∏π‡∏Å‡πÄ‡∏û‡∏¥‡πà‡∏°
droppedItems.ChildAdded:Connect(function(newModel)
    resizePickUpZone(newModel)
end)



-- ‡πÄ‡∏õ‡∏¥‡∏î‡∏Ñ‡πà‡∏≤‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
c().EnabledSkip = true

-- ‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Skip
func['EnabledSkip'] = function()
    while c().EnabledSkip do
        task.wait() -- ‡πÉ‡∏ä‡πâ task.wait() ‡∏î‡∏µ‡∏Å‡∏ß‡πà‡∏≤ waits() (‡πÄ‡∏£‡πá‡∏ß‡πÅ‡∏•‡∏∞‡∏ô‡∏¥‡πà‡∏á‡∏Å‡∏ß‡πà‡∏≤)
        if CrateController and CrateController.spinning and CrateController.spinning.get() then
            CrateController.skip_spin()
        end
    end
end

task.spawn(func['EnabledSkip'])

local AntiRagdoll = false

c().EnabledSpeed = false
c().SpeedAmount = 24


func['EnabledSpeed'] = function()
	while waits() do
		if c().EnabledSpeed then 
			Humanoid:SetAttribute("TargetWalkSpeed", c().SpeedAmount)
            Humanoid.WalkSpeed = c().SpeedAmount
            ServerFunc:Action("set_sprinting_1", true)
        else 
            ServerFunc:Action("set_sprinting_1", false)
            Humanoid:SetAttribute("TargetWalkSpeed", 8)
			Humanoid.WalkSpeed = 8
		end
	end
end


func['EnabledSnap'] = function()
    local baseY = RootPart.Position.Y
    local lastOffset = c().YOffset or 1

    while c().EnabledSnap do
     waits()
        if Humanoid.Health > 0 then
            local currentOffset = c().YOffset or 1
            if currentOffset ~= lastOffset then
                lastOffset = currentOffset
            end
            local targetY = baseY - currentOffset
            local currentPos = RootPart.Position
            RootPart.CFrame = CFrame.new(currentPos.X, targetY, currentPos.Z) * RootPart.CFrame.Rotation
        end
    end
end








 c().EnabledInventoryViewer = false


task.spawn(function()
	while waits(1) do 
		pcall(function()
			for _, player in get(Players:GetPlayers()) do
				if player ~= Client and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
					local head = player.Character.HumanoidRootPart

					local gui = head:FindFirstChild("ItemBillboard")
					if not gui then
						gui = Instance.new("BillboardGui")
						gui.Name = "ItemBillboard"
						gui.AlwaysOnTop = true
						gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
						gui.Size = UDim2.new(0, 200, 0, 50)
						gui.StudsOffset = Vector3.new(0, -5, 0)
						gui.Parent = head
						gui.ExtentsOffset = Vector3.new(0, 1, 0)
						gui.LightInfluence = 1

						local bg = Instance.new("Frame")
						bg.Name = "BG"
						bg.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
						bg.BackgroundTransparency = 1
						bg.Size = UDim2.new(1, 0, 1, 0) 
						bg.AnchorPoint = Vector2.new(0.5, 0.5)
						bg.Position = UDim2.new(0.5, 0, 0.5, 0) 
						bg.Parent = gui

						local layout = Instance.new("UIListLayout")
						layout.FillDirection = Enum.FillDirection.Horizontal
						layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
						layout.VerticalAlignment = Enum.VerticalAlignment.Center
						layout.Padding = UDim.new(0, 5)
						layout.Parent = bg
					end

					local bg = gui:FindFirstChild("BG")
					for _, v in get(bg:GetChildren()) do
						if v:IsA("ImageLabel") then
							v:Destroy()
						end
					end

					local hasItem = false

					for _, container in get({player.Backpack, player.Character}) do
						for _, v in get(container:GetChildren()) do
							if v:IsA("Tool") and not v:GetAttribute("JobTool") then
								if not v:GetAttribute('Locked') then 
									local itemList = nil
									if v:GetAttribute("AmmoType") then
										itemList = replicated.Items.gun:GetChildren()
									else
										itemList = replicated.Items.melee:GetChildren()
									end

									for _, z in get(itemList) do
										if v:GetAttribute("RarityName") == z:GetAttribute("RarityName") and 
										   v:GetAttribute("RarityPrice") == z:GetAttribute("RarityPrice") then
											local imageId = z:GetAttribute("ImageId")
											if imageId then
												local icon = Instance.new("ImageLabel")
												icon.Name = z.Name
												icon.Image = imageId
												icon.BackgroundTransparency = 1
												icon.Size = UDim2.new(0, 30, 0, 30)
												icon.Parent = bg
												hasItem = true
											end
										end
									end
								end
							end
						end
					end

					if not hasItem then
						gui:Destroy()
					else
						gui.Enabled = c().EnabledInventoryViewer
					end
				end
			end
		end)
	end
end)


c().EnabledFpsLimit = true

function v()
    if c().EnabledFpsLimit then 
        print("work")
        setfpscap(90) -- ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ FPS Limit ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ ‡πÄ‡∏ä‡πà‡∏ô 60
    else 
        setfpscap(150) -- ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏à‡∏≥‡∏Å‡∏±‡∏î FPS
    end
end

-- ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏î‡∏™‡∏≠‡∏ö
v()




-- */  Toggle Tab  /* --
do
    local ToggleTab = Window:Tab({
        Title = "Main",
        Icon = "arrow-left-right"
    })
    



   local moneyButton = ToggleTab:Button({
    Title = "Bank üèõ",
    Desc = "Loading...",
    })
    
    ToggleTab:Space()
    
    local moneyhand =ToggleTab:Button({
     Title = "Hand üíµ",
     Desc = "Loading..."
    
    })
    

    local function updateMoney(newMoney, handnew)
    local bank = 0
    local hand = 0 
    if newMoney and newMoney.bank then
        bank = newMoney.bank
    elseif Data.money and Data.money.bank then
        bank = Data.money.bank
    end
    if handnew and handnew.hand then
        hand = handnew.hand
    elseif Data.money and Data.money.hand then
        hand = Data.money.hand
    end
    if moneyButton and moneyButton.SetDesc and moneyhand and moneyhand.SetDesc then
        moneyButton:SetDesc(" $" .. tostring(bank))
        moneyhand:SetDesc(" $" .. tostring(hand))
    end
end
updateMoney(Data.money)
Data.hook("money", function(newMoney)
    updateMoney(newMoney)
end)


    
  
  ToggleTab:Space()
    local Aim = ToggleTab:Toggle({
      Title = "SilentAim",
      Value = false,
      Callback = function(state)
        SilentAim = state
      end
    })
  
  
  local toggleState = false
    local featureToggle = ToggleTab:Toggle({
      Title = "Show FOV Circle",
      Value = false,
      Callback = function(state)
        toggleState = state
        fovCircle.Visible = state
      end
    })
   


local intensitySlider = ToggleTab:Slider({
    Title = "Fov Radius",
    Value = { Min = 200, Max = 600, Default = 200 },
    Callback = function(value)
        c().Radius = tonumber(value)
    end
    })


    
    
    ToggleTab:Space()
    
    local Snap = ToggleTab:Toggle({
      Title = "Snap",
      Value = false,
      Callback = function(state)
        c().EnabledSnap = state
        task.spawn(func['EnabledSnap'])
      end
    })
    
    local Yoffset = ToggleTab:Slider({
    Title = "Y Offset",
    Value = { Min = 1, Max = 100.0, Default = 30 },
    Callback = function(value)
        c().YOffset = tonumber(value)
    end
    })
        
    

  
    
end --end tab main


-- */  Button Tab  /* --
do
    local Character = Window:Tab({
        Title = "Character",
        Icon = "mouse-pointer-click",
    })
    
    local antikilll = Character:Toggle({
    Title = "Anti Kill",
    Value = false,
    Callback = function(state)
        antiKillEnabled = state
    end
})

    

local antiRagdoll = Character:Toggle({
    Title = "Anti Ragdoll",
    Value = false, -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏õ‡∏¥‡∏î
    Callback = function(state)
        AntiRagdoll = state
        
   if  AntiRagdoll then
    task.spawn(function()
	while true do
		pcall(function()
			Net.send('end_ragdoll_early')
		end)
		task.wait(0.25) -- ‡∏´‡∏ô‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤ 0.1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ (‡∏õ‡∏£‡∏±‡∏ö‡πÑ‡∏î‡πâ)
	  end
   end)
     print("‡∏ó‡∏≥‡∏á‡∏≤‡∏ô")
   else
     print("‡πÑ‡∏°‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô")
end
    end
})

    
local highJumpEnabled = false
local jumpHeight = 30 

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ High Jump ‡πÉ‡∏´‡πâ‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£
local function setupHighJump(character)
    local humanoid = character:FindFirstChild("Humanoid")
    if humanoid then
        humanoid.JumpHeight = highJumpEnabled and jumpHeight or 7.2
    end
end
if pls.Character then
    setupHighJump(pls.Character)
end
pls.CharacterAdded:Connect(function(character)
    setupHighJump(character)
end)


-- Toggle ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö High Jump
local jumpToggle = Character:Toggle({
    Title = "High Jump",
    Value = false, -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏õ‡∏¥‡∏î
    Callback = function(state)
        highJumpEnabled = state

        -- ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤ JumpHeight ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
        if pls.Character and pls.Character:FindFirstChild("Humanoid") then
            pls.Character.Humanoid.JumpHeight = state and jumpHeight or 7.2
        end

        
    end
})


local longStrideEnabled = false
local strideLength = 4.5

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Å‡πâ‡∏≤‡∏ß‡∏¢‡∏≤‡∏ß‡πÉ‡∏´‡πâ‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£
local function setupLongStride(character)
    local humanoid = character:FindFirstChild("Humanoid")
    local root = character:FindFirstChild("HumanoidRootPart")

    if humanoid and root then
        -- ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Å‡πâ‡∏≤‡∏ß‡∏¢‡∏≤‡∏ß
        RunService.RenderStepped:Connect(function()
            if longStrideEnabled and humanoid.MoveDirection.Magnitude > 0 then
                root.CFrame = root.CFrame + humanoid.MoveDirection * strideLength * 0.05
            end
        end)
    end
end

-- ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£‡πÅ‡∏•‡πâ‡∏ß
if Client.Character then
    setupLongStride(Client.Character)
end

-- ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏¥‡∏î‡πÉ‡∏´‡∏°‡πà
Client.CharacterAdded:Connect(function(character)
    setupLongStride(character)
end)

-- Toggle ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Long Stride
local longStrideToggle = Character:Toggle({
    Title = "WalkSpeed",
    Value = false, -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏õ‡∏¥‡∏î
    Callback = function(state)
        longStrideEnabled = state

    end
})

local StrideSlider = Character:Slider({
    Title = "Stride Length",
    Value = { Min = 3, Max = 5, Default = 3 },
    Callback = function(value)
      strideLength = value
    end
 })
 
local InfinityStamina = Character:Toggle({
    Title = "Infinity Stamina",
    Value = false,
    Callback = function(state)
        c().EnabledSpeed = state
        if state then
            task.spawn(func['EnabledSpeed'])
        else
            c().EnabledSpeed = false
        end
    end
})
   

local AutoPickItem = Character:Toggle({
    Title = "PickItem",
    Value = false, -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏õ‡∏¥‡∏î
    Callback = function(state)
    c().AutoPickItem = state
    pickUpZoneEnabled = state
        resizeAll() -- ‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
    end
})

    
    Character:Space()
    
local cilam = Character:Toggle({
    Title = "Clear Quest",
    Value = false, -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏õ‡∏¥‡∏î
    Callback = function(state)
        if state then
            local QuestAll = PlayerGui.Quests.QuestsHolder.QuestsScrollingFrame
            for _, v in pairs(QuestAll:GetChildren()) do
                if v.Name ~= "UIListLayout" then
                    ServerFunc:Action("claim_quest", v.Name)
                end
            end
        end
    end
})

    
end


-- */  Input Tab  /* --
do
    local Esp = Window:Tab({
        Title = "ESP",
        Icon = "text-cursor-input",
    })
    
    
    local espbox1 = Esp:Toggle({
    Title = "Esp 3DBox",
    Value = false, -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏õ‡∏¥‡∏î
    Callback = function(state)
         ESPSettings.Box3DEnabled = state
    end
    })
    
    local espSkeleton = Esp:Toggle({
    Title = "Esp Skeleton",
    Value = false, -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏õ‡∏¥‡∏î
    Callback = function(state)
         ESPSettings.SkeletonEnabled = state
    end
    })
    
    
    local espbox2 = Esp:Toggle({
    Title = "Esp Name",
    Value = false, -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏õ‡∏¥‡∏î
    Callback = function(state)
         ESPSettings.NameEnabled = state
    end
    })
    
    
    local espbox3 = Esp:Toggle({
    Title = "Esp Hp",
    Value = false, -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏õ‡∏¥‡∏î
    Callback = function(state)
         ESPSettings.HealthEnabled = state
    end
     })
     
    local espbox4 = Esp:Toggle({
    Title = "Esp InventoryViewer",
    Value = false, -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏õ‡∏¥‡∏î
    Callback = function(state)
         c().EnabledInventoryViewer = state
    end
     })
     
    local espbox3 = Esp:Toggle({
    Title = "Esp Viewer Items 3D Box",
    Value = false, -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏õ‡∏¥‡∏î
    Callback = function(state)
         ESPSettings.EspViewitems = state
    end
     })

end



do

local Players = game:GetService("Players")

local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer

local character = player.Character or player.CharacterAdded:Wait()

local ANIMATION_ID = "100203839720961"

local screenGui = Instance.new("ScreenGui")

screenGui.Name = "AnimationGUI"

screenGui.ResetOnSpawn = false  

screenGui.Parent = player.PlayerGui

local mainFrame = Instance.new("Frame")

mainFrame.Size = UDim2.new(0, 200, 0, 100)

mainFrame.Position = UDim2.new(0, 10, 0, 10)

mainFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)

mainFrame.BorderSizePixel = 0

mainFrame.Parent = screenGui

local corner = Instance.new("UICorner")

corner.CornerRadius = UDim.new(0, 8)

corner.Parent = mainFrame

local title = Instance.new("Frame")

title.Size = UDim2.new(1, 0, 0, 30)

title.Position = UDim2.new(0, 0, 0, 0)

title.BackgroundColor3 = Color3.fromRGB(30, 30, 30)

title.Parent = mainFrame

local titleCorner = Instance.new("UICorner")

titleCorner.CornerRadius = UDim.new(0, 8)

titleCorner.Parent = title

local titleText = Instance.new("TextLabel")

titleText.Size = UDim2.new(0.8, 0, 1, 0)

titleText.Position = UDim2.new(0, 5, 0, 0)

titleText.BackgroundTransparency = 1

titleText.Text = "Invisible | DZHUB"

titleText.TextColor3 = Color3.fromRGB(255, 255, 255)

titleText.Font = Enum.Font.GothamBold

titleText.TextSize = 14

titleText.TextXAlignment = Enum.TextXAlignment.Left

titleText.Parent = title

local closeButton = Instance.new("TextButton")

closeButton.Size = UDim2.new(0, 25, 0, 25)

closeButton.Position = UDim2.new(1, -30, 0.5, -12)

closeButton.BackgroundColor3 = Color3.fromRGB(120, 120, 120)

closeButton.Text = "X"

closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)

closeButton.Font = Enum.Font.GothamBold

closeButton.TextSize = 14

closeButton.Parent = title

local closeCorner = Instance.new("UICorner")

closeCorner.CornerRadius = UDim.new(0, 4)

closeCorner.Parent = closeButton

local toggleButton = Instance.new("TextButton")

toggleButton.Size = UDim2.new(0, 120, 0, 40)

toggleButton.Position = UDim2.new(0.5, -60, 0.5, -20)

toggleButton.BackgroundColor3 = Color3.fromRGB(220, 60, 60)

toggleButton.Text = "OFF"

toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)

toggleButton.Font = Enum.Font.GothamBold

toggleButton.TextSize = 16

toggleButton.Parent = mainFrame

local buttonCorner = Instance.new("UICorner")

buttonCorner.CornerRadius = UDim.new(0, 6)

buttonCorner.Parent = toggleButton

local animationTrack

local isPlaying = false

local humanoid

local originalTransparency = {}

local function makeTransparent()

    if not character then return end

    

    for _, part in pairs(character:GetChildren()) do

        if part:IsA("BasePart") then

            originalTransparency[part] = part.Transparency

            part.Transparency = 1

        end

    end

end

local function makeVisible()

    if not character then return end

    

    for part, transparency in pairs(originalTransparency) do

        if part and part.Parent then

            part.Transparency = transparency

        end

    end

    originalTransparency = {}

end

local function loadAnimation()

    if not character then return end

    

    humanoid = character:FindFirstChildOfClass("Humanoid")

    if not humanoid then return end

    

    local animation = Instance.new("Animation")

    animation.AnimationId = "rbxassetid://" .. ANIMATION_ID

    

    animationTrack = humanoid:LoadAnimation(animation)

end

local function stopAnimation()

    if animationTrack then

        animationTrack:Stop()

    end

    makeVisible()

    isPlaying = false

    toggleButton.BackgroundColor3 = Color3.fromRGB(220, 60, 60)

    toggleButton.Text = "OFF"

end

player.CharacterAdded:Connect(function(newChar)

    character = newChar

    wait(1)

    loadAnimation()

    stopAnimation()

end)

player.CharacterRemoving:Connect(function()

    stopAnimation()

end)

loadAnimation()

local function toggleAnimation()

    if not animationTrack then

        loadAnimation()

        if not animationTrack then return end

    end

    

    if isPlaying then

        animationTrack:Stop()

        makeVisible()

        toggleButton.BackgroundColor3 = Color3.fromRGB(220, 60, 60)

        toggleButton.Text = "OFF"

        isPlaying = false

    else

        animationTrack:Play()

        animationTrack:AdjustSpeed(0.5) 

        makeTransparent()

        toggleButton.BackgroundColor3 = Color3.fromRGB(60, 220, 60)

        toggleButton.Text = "ON"

        isPlaying = true

    end

end

toggleButton.MouseButton1Click:Connect(toggleAnimation)

closeButton.MouseButton1Click:Connect(function()

    screenGui:Destroy()

end)

local dragging = false

local dragInput, dragStart, startPos

local function update(input)

    local delta = input.Position - dragStart

    mainFrame.Position = UDim2.new(

        startPos.X.Scale, 

        startPos.X.Offset + delta.X, 

        startPos.Y.Scale, 

        startPos.Y.Offset + delta.Y

    )

end

local function onInputBegan(input)

    if input.UserInputType == Enum.UserInputType.MouseButton1 or 

       input.UserInputType == Enum.UserInputType.Touch then

        dragging = true

        dragStart = input.Position

        startPos = mainFrame.Position

        

        title.BackgroundColor3 = Color3.fromRGB(50, 50, 100)

        

        input.Changed:Connect(function()

            if input.UserInputState == Enum.UserInputState.End then

                dragging = false

                title.BackgroundColor3 = Color3.fromRGB(30, 30, 30)

            end

        end)

    end

end

local function onInputChanged(input)

    if input.UserInputType == Enum.UserInputType.MouseMovement or 

       input.UserInputType == Enum.UserInputType.Touch then

        dragInput = input

    end

end

title.InputBegan:Connect(onInputBegan)

title.InputChanged:Connect(onInputChanged)

mainFrame.InputBegan:Connect(onInputBegan)

mainFrame.InputChanged:Connect(onInputChanged)

UserInputService.InputChanged:Connect(function(input)

    if input == dragInput and dragging then

        update(input)

    end

end)



end







print("heeee")


