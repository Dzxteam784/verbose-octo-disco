local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

Rayfield:LoadConfiguration()


local Window = Rayfield:CreateWindow({
   Name = "DzHub 1.0.0",
   Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
   LoadingTitle = "DzHub Interface Suite",
   LoadingSubtitle = "by dan",
   ShowText = "DzHub", -- for mobile users to unhide rayfield, change if you'd like
   Theme = "Default", -- Check https://docs.sirius.menu/rayfield/configuration/themes

   ToggleUIKeybind = "K", -- The keybind to  the UI visibility (string like "K" or Enum.KeyCode)

   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
      Enabled = true,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = "Big Hub"
   },

   Discord = {
      Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = true, -- Set this to true to use our key system
   KeySettings = {
      Title = "DzHub",
      Subtitle = "Key System",
      Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
      FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"1234"} --‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÅ‡∏ö‡∏ö‡∏´‡∏•‡∏≤‡∏¢‡∏Ñ‡∏µ‡πÑ‡∏î‡πâ‡πÄ‡∏ä‡πà‡∏ô1234,test
   }
})

local Tab = Window:CreateTab("Main", 10723407389) -- Title, Image


-- ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤ Tab = Window:CreateTab("Main", 10723407389) 
local moneyLabel = Tab:CreateLabel("Bank: Loading...") -- ‡∏™‡∏£‡πâ‡∏≤‡∏á Label ‡∏ú‡πà‡∏≤‡∏ô Rayfield

-- ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏Å‡∏±‡∏ö Data Module
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Data = require(ReplicatedStorage.Modules.Core.Data)

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏á‡∏¥‡∏ô
local function updateMoney(newMoney)
    if newMoney and newMoney.bank then
        moneyLabel:Set("üèõ Bank: $" .. tostring(newMoney.bank))
    else
        moneyLabel:Set("Bank: 0")
    end
end

-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡∏ï‡∏≠‡∏ô‡πÄ‡∏õ‡∏¥‡∏î GUI
updateMoney(Data.money)

-- ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ñ‡πà‡∏≤‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô
Data.hook("money", function(newMoney)
    updateMoney(newMoney)
end)










local plr = game:GetService("Players").LocalPlayer

local DROP_Y = -100
local HEALTH_MIN = 20
local HEALTH_RECOVER = 30

local isDropping = false 
local antiKillEnabled = true -- ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏Å‡∏±‡∏ö Toggle

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ character
local function setupCharacter(char)
    local humanoid = char:WaitForChild("Humanoid")
    local rootPart = char:WaitForChild("HumanoidRootPart")

    local function startDrop()
        if not antiKillEnabled then return end
        if isDropping then return end
        isDropping = true

        local fixedPos = rootPart.Position  
        fixedPos = Vector3.new(fixedPos.X, fixedPos.Y + DROP_Y, fixedPos.Z)  

        while isDropping do  
            if humanoid.Health >= HEALTH_RECOVER or humanoid.Health <= 0 then
                isDropping = false
                break
            end  
            rootPart.CFrame = CFrame.new(fixedPos)  
            task.wait(0.0001)
        end
    end

    humanoid.HealthChanged:Connect(function(hp)
        if hp < HEALTH_MIN and hp > 0 then
            startDrop()
        end
    end)
end

-- ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ï‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°
if plr.Character then
    setupCharacter(plr.Character)
end

-- ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà respawn
plr.CharacterAdded:Connect(setupCharacter)




local AntiKillToggle = Tab:CreateToggle({
    Name = "AntiKill",
    CurrentValue = false,
    Flag = "AntiKillToggle",
    Callback = function(Value)
        antiKillEnabled = Value
    end
})





local SprintModule = require(game:GetService("ReplicatedStorage").Modules.Game.Sprint)
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î‡∏£‡∏∞‡∏ö‡∏ö
local SprintInfinitiEnabled = false 

-- ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï WalkSpeed ‡∏ó‡∏∏‡∏Å‡πÄ‡∏ü‡∏£‡∏°
game:GetService("RunService").RenderStepped:Connect(function()
    if SprintInfinitiEnabled then
        local char = LocalPlayer.Character
        if char and char:FindFirstChild("Humanoid") then
            local hum = char.Humanoid
            -- ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì WalkSpeed ‡∏ï‡∏≤‡∏° sprinting
            local speedMultiplier = LocalPlayer:GetAttribute("SpeedMultiplier") or 1
            local baseSpeed = game.StarterPlayer.CharacterWalkSpeed
            hum.WalkSpeed = baseSpeed * speedMultiplier * 2.2 -- Sprint 2.2x
            hum:SetAttribute("TargetWalkSpeed", hum.WalkSpeed)
        end
    end
end)

-- ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô module ‡∏õ‡∏¥‡∏î sprinting
SprintModule.sprinting.hook(function(newValue)
    if SprintInfinitiEnabled and newValue == false then
        SprintModule.sprinting.set(true)
    end
end)

-- ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏õ‡∏∏‡πà‡∏° Toggle
local SpringInfiniti = Tab:CreateToggle({
    Name = "Sprint Infiniti",
    CurrentValue = false,
    Flag = "SprintInfiniti",
    Callback = function(Value)
        SprintInfinitiEnabled = Value
    end
})




local ChamsEnabled = false -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏õ‡∏¥‡∏î‡πÑ‡∏ß‡πâ

local ATMFolder = workspace:WaitForChild("Map"):WaitForChild("Props"):WaitForChild("ATMs")

local function addChams(atm)
    if not atm:IsA("Model") then return end
    if atm:FindFirstChild("ATMHighlight") then return end

    -- ‡∏™‡∏£‡πâ‡∏≤‡∏á Highlight
    local highlight = Instance.new("Highlight")
    highlight.Name = "ATMHighlight"
    highlight.Adornee = atm
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.FillColor = Color3.fromRGB(0, 255, 0)
    highlight.Enabled = false
    highlight.Parent = atm

    -- ‡∏´‡∏≤ ProximityPrompt
    local prompt = atm:FindFirstChildWhichIsA("ProximityPrompt", true)
    if not prompt then return end

    task.spawn(function()
        while atm.Parent do
            if ChamsEnabled and prompt.Enabled then
                highlight.Enabled = true
                highlight.FillColor = Color3.fromRGB(0, 255, 0)
            else
                highlight.Enabled = false
            end
            task.wait(0.2)
        end
    end)
end

-- ‡πÉ‡∏™‡πà Chams ‡πÉ‡∏´‡πâ ATM ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
for _, atm in pairs(ATMFolder:GetChildren()) do
    addChams(atm)
end

-- ‡πÉ‡∏™‡πà Chams ‡πÉ‡∏´‡πâ ATM ‡∏ó‡∏µ‡πà Spawn ‡πÉ‡∏´‡∏°‡πà
ATMFolder.ChildAdded:Connect(addChams)

-- ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏õ‡∏∏‡πà‡∏° Toggle ‡πÉ‡∏ô UI
local ChamsToggle = Tab:CreateToggle({
    Name = "ATM Chams",
    CurrentValue = false,
    Flag = "ChamsToggle",
    Callback = function(Value)
        ChamsEnabled = Value
        print("ChamsEnabled =", ChamsEnabled)
    end
})







local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local SendRemote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Send")
local Camera = workspace.CurrentCamera

-- ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á GUI ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
local guiPosition = LocalPlayer.PlayerGui.SelectPlayer.ChoosePlayerHolder.AbsolutePosition
local guiSize = LocalPlayer.PlayerGui.SelectPlayer.ChoosePlayerHolder.AbsoluteSize

-- FOV Circle
local fovCircle = Drawing.new("Circle")
fovCircle.Radius = 200
fovCircle.Color = Color3.new(0,1,0)
fovCircle.Thickness = 2
fovCircle.Filled = false
fovCircle.Visible = true
fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

-- ‡∏´‡∏≤‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÉ‡∏ô FOV
local function getClosestTargetInFOV()
    local closestDistance = math.huge
    local closestHumanoidPart = nil

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local head = player.Character:FindFirstChild("Head")
            if head then
                local screenPos, onScreen = Camera:WorldToViewportPoint(head.Position)
                if onScreen then
                    local distToCenter = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)).Magnitude
                    if distToCenter <= fovCircle.Radius and distToCenter < closestDistance then
                        closestDistance = distToCenter
                        closestHumanoidPart = head
                    end
                end
            end
        end
    end

    return closestHumanoidPart
end

-- ESP Line
local line = Drawing.new("Line")
line.Color = Color3.new(1,0,0)
line.Thickness = 2
line.Transparency = 1

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á Tracer
local function createTracer(startPos, endPos, hitPlayer)
    local tracer = Instance.new("Part")
    tracer.Anchored = true
    tracer.CanCollide = false
    tracer.Material = Enum.Material.Neon
    tracer.Color = hitPlayer and Color3.new(1,0,0) or Color3.new(199, 212, 228)
    tracer.Size = Vector3.new(0.1, 0.1, (startPos - endPos).Magnitude)
    tracer.CFrame = CFrame.new((startPos + endPos)/2, endPos)
    tracer.Parent = workspace
    game:GetService("Debris"):AddItem(tracer, 1)
end

-- Update FOV + ESP
RunService.RenderStepped:Connect(function()
    fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

    -- ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á GUI
    guiPosition = LocalPlayer.PlayerGui.SelectPlayer.ChoosePlayerHolder.AbsolutePosition
    guiSize = LocalPlayer.PlayerGui.SelectPlayer.ChoosePlayerHolder.AbsoluteSize
    
    -- ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏∏‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏Ç‡∏≠‡∏á GUI ‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡∏ï‡πà‡∏≥‡∏•‡∏á
    local guiCenter = Vector2.new(
        guiPosition.X + guiSize.X / 2,
        guiPosition.Y + guiSize.Y + 58  -- ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡πà‡∏≤ Y ‡πÉ‡∏´‡πâ‡∏ï‡πà‡∏≥‡∏•‡∏á 50 pixels ‡∏à‡∏≤‡∏Å‡∏Ç‡∏≠‡∏ö‡∏•‡πà‡∏≤‡∏á‡∏Ç‡∏≠‡∏á GUI
    )

    local target = getClosestTargetInFOV()
    if target then
        local endPos = Camera:WorldToViewportPoint(target.Position)

        -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å GUI ‡πÑ‡∏õ‡∏´‡∏≤‡∏®‡∏±‡∏ï‡∏£‡∏π
        line.From = guiCenter
        line.To = Vector2.new(endPos.X, endPos.Y)
        line.Visible = true
    else
        line.Visible = false
    end
end)

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏î‡∏±‡∏Å‡∏´‡∏ô‡πâ‡∏≤
local function getPredictedPosition(target)
    local root = target.Parent:FindFirstChild("HumanoidRootPart")
    if not root then return target.Position end

    local velocity = root.Velocity or Vector3.new(0,0,0)
    local ping = 0.19 -- ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏ß‡∏•‡∏≤ lag/ping (‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏£‡∏¥‡∏á)
    
    -- ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏Ñ‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡∏ì‡πå‡∏≠‡∏ô‡∏≤‡∏Ñ‡∏ï
    local predictedPos = target.Position + velocity * ping
    return predictedPos
end

-- Hook FireServer ‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡∏¢‡∏¥‡∏á‡∏î‡∏±‡∏Å‡∏´‡∏ô‡πâ‡∏≤
local oldSendFire
oldSendFire = hookfunction(SendRemote.FireServer, function(self, ...)
    local args = {...}

    if type(args[2]) == "string" and args[2]:lower():find("shoot") then
        local targetHead = getClosestTargetInFOV()
        if targetHead and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local predictedPos = getPredictedPosition(targetHead)

            -- ‡∏¢‡∏¥‡∏á‡πÑ‡∏õ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏Ñ‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡∏ì‡πå
            args[4] = CFrame.new(LocalPlayer.Character.Head.Position, predictedPos)
            args[5] = {
                {
                    {
                        Instance = targetHead,
                        Position = predictedPos,
                        Normal = (predictedPos - LocalPlayer.Character.Head.Position).Unit,
                        Material = Enum.Material.Plastic,
                        Distance = (predictedPos - LocalPlayer.Character.Head.Position).Magnitude
                    }
                }
            }

            -- Tracer (‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÑ‡∏õ‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Ñ‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡∏ì‡πå)
            createTracer(LocalPlayer.Character.HumanoidRootPart.Position, predictedPos, true)
        end
    end

    return oldSendFire(self, unpack(args))
end)





local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- ESP Settings
local ESPSettings = {
    Box3DEnabled = true, -- ‚úÖ ‡πÉ‡∏ä‡πâ Box 3D ‡πÅ‡∏ó‡∏ô 2D
    SkeletonEnabled = false,
    NameEnabled = false,
    DistanceEnabled = false,
    HealthEnabled = true, -- ‚úÖ ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏•‡∏∑‡∏≠‡∏î
    BoxColor = Color3.fromRGB(255,255,255),
    LockColor = Color3.fromRGB(255,0,0),
    NameColor = Color3.fromRGB(255,255,255),
    HealthColor = Color3.fromRGB(0,255,0)
}

-- Store Drawing objects
local ESPObjects = {}

-- Function to remove ESP when player leaves
local function removeESP(player)
    if ESPObjects[player] then
        for _, obj in pairs(ESPObjects[player]) do
            if typeof(obj) == "table" then
                for _, v in ipairs(obj) do v:Remove() end
            else
                obj:Remove()
            end
        end
        ESPObjects[player] = nil
    end
end

-- Function to create ESP for a player
local function createESP(player)
    -- Box 3D (12 ‡πÄ‡∏™‡πâ‡∏ô)
    local box3D = {}
    for i = 1, 12 do
        local line = Drawing.new("Line")
        line.Thickness = 1
        line.Color = ESPSettings.BoxColor
        line.Visible = false
        table.insert(box3D, line)
    end

    -- Name
    local nameText = Drawing.new("Text")
    nameText.Size = 10
    nameText.Color = ESPSettings.NameColor
    nameText.Center = true
    nameText.Outline = true
    nameText.Visible = false

    -- Distance
    local distanceText = Drawing.new("Text")
    distanceText.Size = 7
    distanceText.Center = true
    distanceText.Outline = true
    distanceText.Visible = false

    -- Health text
    local healthText = Drawing.new("Text")
    healthText.Size = 8
    healthText.Color = ESPSettings.HealthColor
    healthText.Center = true
    healthText.Outline = true
    healthText.Visible = false

    ESPObjects[player] = {
        Box3D = box3D,
        Name = nameText,
        Distance = distanceText,
        Health = healthText
    }
end

-- Create ESP for existing players
for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        createESP(player)
    end
end

-- Create ESP for new players
Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        createESP(player)
    end
end)

-- Remove ESP when player leaves
Players.PlayerRemoving:Connect(function(player)
    removeESP(player)
end)

-- Function to get closest target
local function getClosestTargetInFOV()
    local closestDistance = math.huge
    local closestTarget = nil
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local part = player.Character:FindFirstChild("Head") or player.Character:FindFirstChild("HumanoidRootPart")
            if part then
                local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local distToCenter = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)).Magnitude
                    if distToCenter < closestDistance then
                        closestDistance = distToCenter
                        closestTarget = part
                    end
                end
            end
        end
    end
    return closestTarget
end

-- üîπ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï Box 3D
local function updateBox3D(player, obj)
    local char = player.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return end

    local hrp = char.HumanoidRootPart
    local cf, size = hrp.CFrame, Vector3.new(4, 7, 4)

    local corners = {
        Vector3.new(-size.X, -size.Y, -size.Z) / 2,
        Vector3.new( size.X, -size.Y, -size.Z) / 2,
        Vector3.new( size.X,  size.Y, -size.Z) / 2,
        Vector3.new(-size.X,  size.Y, -size.Z) / 2,
        Vector3.new(-size.X, -size.Y,  size.Z) / 2,
        Vector3.new( size.X, -size.Y,  size.Z) / 2,
        Vector3.new( size.X,  size.Y,  size.Z) / 2,
        Vector3.new(-size.X,  size.Y,  size.Z) / 2,
    }

    local screenCorners, visCount = {}, 0
    for i, v in ipairs(corners) do
        local worldPos = (cf * CFrame.new(v)).Position
        local screenPos, onScreen = Camera:WorldToViewportPoint(worldPos)
        screenCorners[i] = Vector2.new(screenPos.X, screenPos.Y)
        if onScreen then visCount += 1 end
    end

    local edges = {
        {1,2},{2,3},{3,4},{4,1},
        {5,6},{6,7},{7,8},{8,5},
        {1,5},{2,6},{3,7},{4,8},
    }

    local lines = obj.Box3D
    if ESPSettings.Box3DEnabled and visCount == 8 then
        local target = getClosestTargetInFOV()
        local color = (target and target.Parent == char) and ESPSettings.LockColor or ESPSettings.BoxColor

        for i, e in ipairs(edges) do
            local line = lines[i]
            line.From = screenCorners[e[1]]
            line.To   = screenCorners[e[2]]
            line.Color = color
            line.Visible = true
        end
    else
        for _, l in ipairs(lines) do l.Visible = false end
    end
end

-- Update ESP
RunService.RenderStepped:Connect(function()
    for player, obj in pairs(ESPObjects) do
        local char = player.Character
        if char and char:FindFirstChild("HumanoidRootPart") and char:FindFirstChild("Humanoid") then
            local root = char.HumanoidRootPart
            local head = char:FindFirstChild("Head")
            local humanoid = char.Humanoid

            local screenHead, headOnScreen = Camera:WorldToViewportPoint(head.Position)
            local distance = (root.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude

            if headOnScreen then
                -- ‚úÖ Box 3D
                updateBox3D(player, obj)

                -- Name
                if ESPSettings.NameEnabled then
                    obj.Name.Text = player.Name
                    obj.Name.Position = Vector2.new(screenHead.X, screenHead.Y - 10)
                    obj.Name.Visible = true
                else
                    obj.Name.Visible = false
                end

                -- Distance
                if ESPSettings.DistanceEnabled then
                    obj.Distance.Text = string.format("%.0f", distance).."m"
                    obj.Distance.Position = Vector2.new(screenHead.X, screenHead.Y + 20)
                    obj.Distance.Visible = true
                else
                    obj.Distance.Visible = false
                end

                -- ‚úÖ Health
                if ESPSettings.HealthEnabled then
                    obj.Health.Text = string.format("%d HP", math.floor(humanoid.Health))
                    obj.Health.Position = Vector2.new(screenHead.X, screenHead.Y + 35)
                    obj.Health.Visible = true
                else
                    obj.Health.Visible = false
                end
            else
                updateBox3D(player, obj)
                obj.Name.Visible = false
                obj.Distance.Visible = false
                obj.Health.Visible = false
            end
        else
            updateBox3D(player, obj)
            obj.Name.Visible = false
            obj.Distance.Visible = false
            obj.Health.Visible = false
        end
    end
end)



-- Toggle UI ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ESP
local ESPBoxToggle = Tab:CreateToggle({
    Name = "ESP Box 3D + HP",
    CurrentValue = ESPSettings.BoxEnabled,
    Flag = "ESPBoxToggle",
    Callback = function(Value)
        ESPSettings.Box3DEnabled = Value
    end
})

local ESPSkeletonToggle = Tab:CreateToggle({
    Name = "ESP Skeleton",
    CurrentValue = ESPSettings.SkeletonEnabled,
    Flag = "ESPSkeletonToggle",
    Callback = function(Value)
        ESPSettings.SkeletonEnabled = Value
    end
})

local ESPNameToggle = Tab:CreateToggle({
    Name = "ESP Name",
    CurrentValue = ESPSettings.NameEnabled,
    Flag = "ESPNameToggle",
    Callback = function(Value)
        ESPSettings.NameEnabled = Value
    end
})

local ESPDistanceToggle = Tab:CreateToggle({
    Name = "ESP Distance",
    CurrentValue = ESPSettings.DistanceEnabled,
    Flag = "ESPDistanceToggle",
    Callback = function(Value)
        ESPSettings.DistanceEnabled = Value
    end
})



