local WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/Dzxteam784/DZHUB/refs/heads/main/dist/main.lua"))()


local SOUND_ID = "rbxassetid://232127604"

local sound = Instance.new("Sound")
sound.Name = "LocalSound"
sound.SoundId = SOUND_ID
sound.Volume = 1
sound.PlaybackSpeed = 0.8
sound.Looped = false

-- ‡πÉ‡∏™‡πà‡πÄ‡∏Ç‡πâ‡∏≤ SoundService ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏õ‡πá‡∏ô ‚ÄúLocal Only‚Äù
sound.Parent = game:GetService("SoundService")


local Window = WindUI:CreateWindow({
    Title = "DZHUB'Dev | v-1.0 PvP - Test",
    Author = "by danzaza",
    
    BackgroundImageTransparency = 0.25,
    HideSearchBar = false,
    Folder = "Dzhub",
  
    SideBarWidth = 200,
    
    KeySystem = {
        Note = "Key System Dzhub.",
        SaveKey = false,
        Key = { "1234", "test" },
        URL = "https://github.com/Footagesus/WindUI",
        Thumbnail = {
            Image = "rbxassetid://134656917989517",
        },
    },
    
    
    OpenButton = {
        Title = "DZHUB | v-1.0",
        Enabled = true,
        Draggable = true,
        OnlyMobile = false,

        OnlyIcon = true,     -- ‡πÉ‡∏ä‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÇ‡∏•‡πÇ‡∏Å‡πâ
        Icon = "rbxassetid://134656917989517",

        StrokeThickness = 0, -- ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡∏≠‡∏ö
    }
})

sound:Play()

-- */ Other Functions /* --
local function parseJSON(luau_table, indent, level, visited)
    indent = indent or 2
    level = level or 0
    visited = visited or {}
    
    local currentIndent = string.rep(" ", level * indent)
    local nextIndent = string.rep(" ", (level + 1) * indent)
    
    if luau_table == nil then
        return "null"
    end
    
    local dataType = type(luau_table)
    
    if dataType == "table" then
        if visited[luau_table] then
            return "\"[Circular Reference]\""
        end
        
        visited[luau_table] = true
        
        local isArray = true
        local maxIndex = 0
        
        for k, _ in pairs(luau_table) do
            if type(k) == "number" and k > maxIndex then
                maxIndex = k
            end
            if type(k) ~= "number" or k <= 0 or math.floor(k) ~= k then
                isArray = false
                break
            end
        end
        
        local count = 0
        for _ in pairs(luau_table) do
            count = count + 1
        end
        if count ~= maxIndex and isArray then
            isArray = false
        end
        
        if count == 0 then
            return "{}"
        end
        
        if isArray then
            if count == 0 then
                return "[]"
            end
            
            local result = "[\n"
            
            for i = 1, maxIndex do
                result = result .. nextIndent .. parseJSON(luau_table[i], indent, level + 1, visited)
                if i < maxIndex then
                    result = result .. ","
                end
                result = result .. "\n"
            end
            
            result = result .. currentIndent .. "]"
            return result
        else
            local result = "{\n"
            local first = true
            
            local keys = {}
            for k in pairs(luau_table) do
                table.insert(keys, k)
            end
            table.sort(keys, function(a, b)
                if type(a) == type(b) then
                    return tostring(a) < tostring(b)
                else
                    return type(a) < type(b)
                end
            end)
            
            for _, k in ipairs(keys) do
                local v = luau_table[k]
                if not first then
                    result = result .. ",\n"
                else
                    first = false
                end
                
                if type(k) == "string" then
                    result = result .. nextIndent .. "\"" .. k .. "\": "
                else
                    result = result .. nextIndent .. "\"" .. tostring(k) .. "\": "
                end
                
                result = result .. parseJSON(v, indent, level + 1, visited)
            end
            
            result = result .. "\n" .. currentIndent .. "}"
            return result
        end
    elseif dataType == "string" then
        local escaped = luau_table:gsub("\\", "\\\\")
        escaped = escaped:gsub("\"", "\\\"")
        escaped = escaped:gsub("\n", "\\n")
        escaped = escaped:gsub("\r", "\\r")
        escaped = escaped:gsub("\t", "\\t")
        
        return "\"" .. escaped .. "\""
    elseif dataType == "number" then
        return tostring(luau_table)
    elseif dataType == "boolean" then
        return luau_table and "true" or "false"
    elseif dataType == "function" then
        return "\"function\""
    else
        return "\"" .. dataType .. "\""
    end
end

local function tableToClipboard(luau_table, indent)
    indent = indent or 4
    local jsonString = parseJSON(luau_table, indent)
    setclipboard(jsonString)
    return jsonString
end

Window:SetBackgroundTransparency(0.1)
Window:SetBackgroundImageTransparency(0.1)

Window:Tag({
    Title = "v1.0.0",
    Color = Color3.fromHex("#FF0000")
})
    


local require = require or getfenv().require
local cloneref = cloneref or function(f) return f end
local Net = require(cloneref(game:GetService('ReplicatedStorage').Modules.Core.Net))
local getupvalue = getupvalue or debug.getupvalue
local setconstant = setconstant or debug.setconstant

do
    local func2 = getupvalue(Net.send, 2)
    setconstant(func2, 1, "...")
    setconstant(func2, 3, "...")
    setconstant(func2, 4, "...")
    setconstant(func2, 9, "...")
    local func = getupvalue(Net.get, 2)
    setconstant(func, 1, "...")
    setconstant(func, 3, "...")
    setconstant(func, 4, "...")
    setconstant(func, 9, "...")

    local real_getfenv = getfenv
    getfenv = function(level)
        if level == 6 then
            local original_env = real_getfenv(6)
            return setmetatable({}, {
                __index = function(self, key)
                    if key == "getgenv" or key == "identifyexecutor" then
                        return nil
                    end
                    return original_env and original_env[key]
                end,
                __newindex = function(self, key, value)
                    if original_env then
                        original_env[key] = value
                    end
                end
            })
        end
        return real_getfenv(level)
    end
end




------------GetService--------------
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local replicated = game:GetService("ReplicatedStorage")


------------Player--------------
local Client = Players.LocalPlayer
local Character = Client.Character or Client.CharacterAdded:Wait()
local UserId = Client.UserId
local PlayerGui = Client.PlayerGui
local Humanoid = Character:WaitForChild("Humanoid")
local RootPart = Character:WaitForChild("HumanoidRootPart")
local Backpack = Client:WaitForChild("Backpack")
local Camera = workspace.CurrentCamera


Client.CharacterAdded:Connect(function(newCharacter)
	Character = newCharacter
	Humanoid = Character:WaitForChild('Humanoid')
	RootPart = Character:WaitForChild('HumanoidRootPart')
	Backpack = Client:WaitForChild("Backpack")
end)	

-------------------Modules--------------------
local Data = require(ReplicatedStorage.Modules.Core.Data)


local get = ipairs
local getn = pairs
local un = unpack

local ServerFunc,func,functionb = {},{},{}; 
ServerFunc.__index = ServerFunc 
func.__index = func


local function c() 
    return getgenv()
end

function ServerFunc:Action(...)
	local args = {...}
	return Net.send(un(args))
end



local fov = Drawing.new("Circle")
fov.Radius = 200
fov.Color = Color3.new(255,255,255)
fov.Thickness = 1.25
fov.Filled = false
fov.Visible = false
fov.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

local SilentAim = false
local line = Drawing.new("Line")
line.Color = Color3.new(1,0,0)
line.Thickness = 1.5
line.Transparency = 1


local function getClosestTargetInFOV()
	local closestDistance = math.huge
	local closestPart = nil

	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= Client and player.Character then
			local head = player.Character:FindFirstChild("Head")
			if head then
				local screenPos, onScreen = Camera:WorldToViewportPoint(head.Position)
				if onScreen then
					local distToCenter = (
                        Vector2.new(screenPos.X, screenPos.Y) -
                        Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                    ).Magnitude
					
					if distToCenter <= fov.Radius and distToCenter < closestDistance then
						closestDistance = distToCenter
						closestPart = head
					end
				end
			end
		end
	end
	return closestPart
end






RunService.RenderStepped:Connect(function()
    local target = getClosestTargetInFOV()

	if target and SilentAim then
		local screenPos, onScreen = Camera:WorldToViewportPoint(target.Position)
		if onScreen then
			line.From = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
			line.To = Vector2.new(screenPos.X, screenPos.Y)
			line.Visible = true
		else
			line.Visible = false
		end
	else
		line.Visible = false
	end
    
    fov.Radius = getgenv().Radius or fov.Radius
    fov.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    
    local ping = Client:GetAttribute("ServerPing")
    if ping then
        -- ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏°‡∏¥‡∏•‡∏•‡∏¥‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
        local pingMs = ping * 1000
        -- ‡∏ï‡∏±‡∏î‡∏ó‡∏®‡∏ô‡∏¥‡∏¢‡∏°‡πÄ‡∏´‡∏•‡∏∑‡∏≠ 3 ‡∏´‡∏•‡∏±‡∏Å
        local formattedPing = string.format("%.3f", pingMs)
      
    end
end)



----antiaim----

local animation = Instance.new("Animation")
animation.AnimationId = "rbxassetid://94324173536622"

local animationTrack
getgenv().Antiaim = false

local function startAntiAim()
    if Humanoid then
        animationTrack = Humanoid:LoadAnimation(animation)
        animationTrack.Looped = true
        animationTrack:Play()
        animationTrack:AdjustSpeed(99999999999999)
    end
end
local function stopAntiAim()
    if animationTrack then
        animationTrack:Stop()
    end
end

local SendRemote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Send")

local function createTracer(startPos, endPos, hitPlayer)
    local tracer = Instance.new("Part")
    tracer.Anchored = true
    tracer.CanCollide = false
    tracer.Material = Enum.Material.Neon
    tracer.Color = hitPlayer and Color3.fromHSV((tick() % 5) / 5, 1, 1)
    tracer.Size = Vector3.new(0.08, 0.08, (startPos - endPos).Magnitude)
    tracer.CFrame = CFrame.new((startPos + endPos)/2, endPos)
    tracer.Parent = workspace
    game:GetService("Debris"):AddItem(tracer, 1.5)
end



local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local SendRemote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Send")
local Camera = workspace.CurrentCamera


local function getPredictedPosition(target)
    local root = target.Parent:FindFirstChild("HumanoidRootPart")
    if not root then return target.Position end

    local velocity = root.Velocity or Vector3.new(0,0,0)
    local ping = 0.28 -- ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏ß‡∏•‡∏≤ lag/ping (‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏£‡∏¥‡∏á)
    local predictedPos = target.Position + velocity * ping
    return predictedPos
end



local oldSendFire
oldSendFire = hookfunction(SendRemote.FireServer, function(self, ...)
    local args = {...}

    if type(args[2]) == "string" and args[2]:lower():find("shoot") then
        local targetHead = getClosestTargetInFOV()
        if targetHead and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local predictedPos = getPredictedPosition(targetHead)
            
            args[4] = CFrame.new(math.huge,math.huge,math.huge)
            args[5] = {
                {
                    {
                        Instance = targetHead,
                        Position = predictedPos,
                        Normal = (predictedPos - LocalPlayer.Character.Head.Position).Unit,
                        Material = Enum.Material.Plastic,
                        Distance = (predictedPos - LocalPlayer.Character.Head.Position).Magnitude
                    },
               
                }
            }

            createTracer(LocalPlayer.Character.HumanoidRootPart.Position, predictedPos, true)
        end
    end

    return oldSendFire(self, unpack(args))
end)






local isInCombat = Client:GetAttribute("IsInCombat")
local plr = game:GetService("Players").LocalPlayer
local DROP_Y = -50
local HEALTH_MIN = 21
local HEALTH_RECOVER = 30
local isDropping = false 
local antiKillEnabled = false
local camera = workspace.CurrentCamera
local cameraLockConn

local function lockCamera()
    local lockedPosition = camera.CFrame.Position
    if cameraLockConn then
        cameraLockConn:Disconnect()
        cameraLockConn = nil
    end

    cameraLockConn = RunService.RenderStepped:Connect(function()
        local lookVector = camera.CFrame.LookVector
        camera.CFrame = CFrame.new(lockedPosition, lockedPosition + lookVector)
    end)
end

local function unlockCamera()
    if cameraLockConn then
        cameraLockConn:Disconnect()
        cameraLockConn = nil
    end
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ character
local function setupCharacter(char)
    local humanoid = char:WaitForChild("Humanoid")
    local rootPart = char:WaitForChild("HumanoidRootPart")

    local function startDrop()
        if not antiKillEnabled then return end
        if isDropping then return end
        isDropping = true
        lockCamera()
        

        local fixedPos = rootPart.Position  
        fixedPos = Vector3.new(fixedPos.X, fixedPos.Y + DROP_Y, fixedPos.Z)  

        local t = 0
        while isDropping do  
            if humanoid.Health >= HEALTH_RECOVER or humanoid.Health <= 0 then
                isDropping = false
                unlockCamera()

                if  isInCombat then
                    print("hee")
                else
                    task.wait(0.6)
                    Net.send('request_respawn')
                end
                break
            end  

            t += 50
            local swingX = math.sin(t * 3000) * 6
            local swingZ = math.cos(t * 3000) * 8
            local newPos = fixedPos + Vector3.new(swingX, math.sin(t * 2) * 2, swingZ)

            rootPart.CFrame = CFrame.new(newPos)
            task.wait() 
        end
    end

    humanoid.HealthChanged:Connect(function(hp)
        if hp < HEALTH_MIN and hp > 0 then
            startDrop()
        end
    end)
end


if plr.Character then
    setupCharacter(plr.Character)
end
plr.CharacterAdded:Connect(setupCharacter)




--[[
	WARNING: Heads up! This script has not been verified by ScriptBlox. Use at your own risk!
]]

getgenv().DesyncEnabled = false


local function clearUnwantedScripts(character)
    for _, v in pairs(character:GetChildren()) do
        if v:IsA("Script") and v.Name ~= "Health" and v.Name ~= "Sound" and v:FindFirstChild("LocalScript") then
            v:Destroy()
        end
    end
end


game.Players.LocalPlayer.CharacterAdded:Connect(function(char)
    repeat task.wait() until char 
    clearUnwantedScripts(char)
    
    char.ChildAdded:Connect(function(child)
        if child:IsA("Script") and child:FindFirstChild("LocalScript") then
            task.wait(0.25) 
            child.LocalScript:FireServer() 
        end
    end)
end)


game:GetService("RunService").Heartbeat:Connect(function()
    if getgenv().DesyncEnabled then
        local hrp = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character.HumanoidRootPart
        if hrp then
            local currentVelocity = hrp.Velocity
            
            hrp.CFrame = hrp.CFrame * CFrame.Angles(0, math.rad(0.0005), 0)
        
            hrp.AssemblyLinearVelocity = Vector3.new(math.random(-50, 50), math.random(0, 50), math.random(-50, 50))   game:GetService("RunService").RenderStepped:Wait() 
            hrp.Velocity = currentVelocity 
        end
    end
end)

local UserInputService = game:GetService("UserInputService")
local toggleKey = Enum.KeyCode.E -- Change this to any key

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if not gameProcessedEvent and input.KeyCode == toggleKey then
        getgenv().DesyncEnabled = not getgenv().DesyncEnabled
        print("Desync " .. (getgenv().DesyncEnabled and "Enabled" or "Disabled"))
    end
end)





 -- ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î Viewer ‡πÅ‡∏ö‡∏ö Global
local settings = {
    EnabledInventoryViewer = false
}

task.spawn(function()
	while task.wait(1) do 
		pcall(function()
			for _, player in ipairs(Players:GetPlayers()) do
				if player ~= Client and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
					
					local head = player.Character.HumanoidRootPart
					local gui = head:FindFirstChild("ItemBillboard")

					-- ‡∏™‡∏£‡πâ‡∏≤‡∏á GUI ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ
					if not gui then
						gui = Instance.new("BillboardGui")
						gui.Name = "ItemBillboard"
						gui.AlwaysOnTop = true
						gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
						gui.Size = UDim2.new(0, 200, 0, 50)
						gui.StudsOffset = Vector3.new(0, -5, 0)
						gui.Parent = head
						gui.ExtentsOffset = Vector3.new(0, 1, 0)
						gui.LightInfluence = 1

						local bg = Instance.new("Frame")
						bg.Name = "BG"
						bg.BackgroundTransparency = 1
						bg.Size = UDim2.new(1, 0, 1, 0)
						bg.AnchorPoint = Vector2.new(0.5, 0.5)
						bg.Position = UDim2.new(0.5, 0, 0.5, 0)
						bg.Parent = gui

						local layout = Instance.new("UIListLayout")
						layout.FillDirection = Enum.FillDirection.Horizontal
						layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
						layout.VerticalAlignment = Enum.VerticalAlignment.Center
						layout.Padding = UDim.new(0, 5)
						layout.Parent = bg
					end

					local bg = gui.BG

					-- ‡∏•‡πâ‡∏≤‡∏á‡∏£‡∏π‡∏õ‡πÄ‡∏Å‡πà‡∏≤
					for _, v in ipairs(bg:GetChildren()) do
						if v:IsA("ImageLabel") then
							v:Destroy()
						end
					end

					local hasItem = false

					-- ‡∏´‡∏≤‡∏Ç‡∏≠‡∏á‡πÉ‡∏ô Backpack + Character
					for _, container in ipairs({player.Backpack, player.Character}) do
						for _, tool in ipairs(container:GetChildren()) do
							if tool:IsA("Tool") and not tool:GetAttribute("JobTool") then
								if not tool:GetAttribute("Locked") then
									
									local itemList
									if tool:GetAttribute("AmmoType") then
										itemList = ReplicatedStorage.Items.gun:GetChildren()
									else
										itemList = ReplicatedStorage.Items.melee:GetChildren()
									end

									for _, z in ipairs(itemList) do
										if tool:GetAttribute("RarityName") == z:GetAttribute("RarityName")
										   and tool:GetAttribute("RarityPrice") == z:GetAttribute("RarityPrice") then
											
											local imageId = z:GetAttribute("ImageId")
											if imageId then
												local icon = Instance.new("ImageLabel")
												icon.Name = z.Name
												icon.Image = imageId
												icon.BackgroundTransparency = 1
												icon.Size = UDim2.new(0, 30, 0, 30)
												icon.Parent = bg
												hasItem = true
											end
										end
									end
								end
							end
						end
					end

					-- ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÑ‡∏≠‡πÄ‡∏ó‡πá‡∏° ‡∏Å‡πá‡∏•‡∏ö GUI
					if not hasItem then
						gui.Enabled = false
					else
						gui.Enabled = settings.EnabledInventoryViewer
					end
				end
			end
		end)
	end
end)



local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- ESP Settings
local ESPSettings = {
    Box3DEnabled = false,
    SkeletonEnabled = false,
    NameEnabled = false,
    DistanceEnabled = false,
    HealthEnabled = false,
    EspViewitems = false,
    BoxColor = Color3.fromRGB(255,255,255),
    LockColor = Color3.fromRGB(255,0,0),
    NameColor = Color3.fromRGB(255,255,255),
    HealthColor = Color3.fromRGB(0,255,0),
    SkeletonColor = Color3.fromRGB(247, 241, 141)
}

-- Store Drawing objects
local ESPObjects = {}

-- Remove ESP when player leaves
local function removeESP(player)
    if ESPObjects[player] then
        for _, obj in pairs(ESPObjects[player]) do
            if typeof(obj) == "table" then
                for _, v in ipairs(obj) do v:Remove() end
            else
                obj:Remove()
            end
        end
        ESPObjects[player] = nil
    end
end

-- Create ESP for a player
local function createESP(player)
    -- Box 3D (12 lines)
    local box3D = {}
    for i = 1, 12 do
        local line = Drawing.new("Line")
        line.Thickness = 1
        line.Color = ESPSettings.BoxColor
        line.Visible = false
        table.insert(box3D, line)
    end

    -- Skeleton (15 lines)
    local skeleton = {}
    for i = 1, 15 do
        local line = Drawing.new("Line")
        line.Thickness = 1
        line.Color = ESPSettings.SkeletonColor
        line.Visible = false
        table.insert(skeleton, line)
    end

    -- Name
    local nameText = Drawing.new("Text")
    nameText.Size = 10
    nameText.Color = ESPSettings.NameColor
    nameText.Center = true
    nameText.Outline = true
    nameText.Visible = false

    -- Distance
    local distanceText = Drawing.new("Text")
    distanceText.Size = 7
    distanceText.Center = true
    distanceText.Outline = true
    distanceText.Visible = false

    -- Health
    local healthText = Drawing.new("Text")
    healthText.Size = 8
    healthText.Color = ESPSettings.HealthColor
    healthText.Center = true
    healthText.Outline = true
    healthText.Visible = false

    ESPObjects[player] = {
        Box3D = box3D,
        Skeleton = skeleton,
        Name = nameText,
        Distance = distanceText,
        Health = healthText
    }
end

-- Create ESP for existing players
for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        createESP(player)
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        createESP(player)
    end
end)

Players.PlayerRemoving:Connect(function(player)
    removeESP(player)
end)


-- Function to get closest target
local function getClosestTargetInFOV()
    local closestDistance = math.huge
    local closestTarget = nil
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local part = player.Character:FindFirstChild("Head") or player.Character:FindFirstChild("HumanoidRootPart")
            if part then
                local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local distToCenter = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)).Magnitude
                    if distToCenter < closestDistance then
                        closestDistance = distToCenter
                        closestTarget = part
                    end
                end
            end
        end
    end
    return closestTarget
end

-- üîπ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï Box 3D
local function updateBox3D(player, obj)
    local char = player.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return end

    local hrp = char.HumanoidRootPart
    local cf, size = hrp.CFrame, Vector3.new(4, 7, 4)

    local corners = {
        Vector3.new(-size.X, -size.Y, -size.Z) / 2,
        Vector3.new( size.X, -size.Y, -size.Z) / 2,
        Vector3.new( size.X,  size.Y, -size.Z) / 2,
        Vector3.new(-size.X,  size.Y, -size.Z) / 2,
        Vector3.new(-size.X, -size.Y,  size.Z) / 2,
        Vector3.new( size.X, -size.Y,  size.Z) / 2,
        Vector3.new( size.X,  size.Y,  size.Z) / 2,
        Vector3.new(-size.X,  size.Y,  size.Z) / 2,
    }

    local screenCorners, visCount = {}, 0
    for i, v in ipairs(corners) do
        local worldPos = (cf * CFrame.new(v)).Position
        local screenPos, onScreen = Camera:WorldToViewportPoint(worldPos)
        screenCorners[i] = Vector2.new(screenPos.X, screenPos.Y)
        if onScreen then visCount += 1 end
    end

    local edges = {
        {1,2},{2,3},{3,4},{4,1},
        {5,6},{6,7},{7,8},{8,5},
        {1,5},{2,6},{3,7},{4,8},
    }

    local lines = obj.Box3D
    if ESPSettings.Box3DEnabled and visCount == 8 then
        local target = getClosestTargetInFOV()
        local color = (target and target.Parent == char) and ESPSettings.LockColor or ESPSettings.BoxColor

        for i, e in ipairs(edges) do
            local line = lines[i]
            line.From = screenCorners[e[1]]
            line.To   = screenCorners[e[2]]
            line.Color = color
            line.Visible = true
        end
    else
        for _, l in ipairs(lines) do l.Visible = false end
    end
end


local ItemESPObjects = {}

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á ESP ‡πÉ‡∏´‡πâ‡∏Ç‡∏≠‡∏á‡∏ï‡∏Å
local function createItemESP(item)
    if not item:IsA("BasePart") and not item:FindFirstChildWhichIsA("BasePart") then return end

    local box3D = {}
    for i = 1, 12 do
        local line = Drawing.new("Line")
        line.Thickness = 1
        line.Color = ESPSettings.BoxColor
        line.Visible = false
        table.insert(box3D, line)
    end

    local nameText = Drawing.new("Text")
    nameText.Size = 9
    nameText.Color = Color3.fromRGB(255, 255, 0)
    nameText.Center = true
    nameText.Outline = true
    nameText.Visible = false

    ItemESPObjects[item] = {
        Box3D = box3D,
        Name = nameText
    }
end

-- ‡∏•‡∏ö ESP ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ç‡∏≠‡∏á‡∏´‡∏≤‡∏¢‡πÑ‡∏õ
local function removeItemESP(item)
    if ItemESPObjects[item] then
        for _, obj in pairs(ItemESPObjects[item]) do
            if typeof(obj) == "table" then
                for _, v in ipairs(obj) do v:Remove() end
            else
                obj:Remove()
            end
        end
        ItemESPObjects[item] = nil
    end
end

-- ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Ç‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á
if droppedItems then
    droppedItems.ChildAdded:Connect(function(item)
        task.wait(0.2)
        createItemESP(item)
    end)

    droppedItems.ChildRemoved:Connect(removeItemESP)

    for _, item in pairs(droppedItems:GetChildren()) do
        createItemESP(item)
    end
end


-- Update ESP
RunService.RenderStepped:Connect(function()
    for player, obj in pairs(ESPObjects) do
        local char = player.Character
        if char and char:FindFirstChild("HumanoidRootPart") and char:FindFirstChild("Humanoid") then
            local root = char.HumanoidRootPart
            local head = char:FindFirstChild("Head")
            local humanoid = char.Humanoid

            local screenHead, headOnScreen = Camera:WorldToViewportPoint(head.Position)
            local distance = (root.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude

            if headOnScreen then
                updateBox3D(player, obj)

                -- Name
                if ESPSettings.NameEnabled then
                    obj.Name.Text = player.Name
                    obj.Name.Position = Vector2.new(screenHead.X, screenHead.Y - 10)
                    obj.Name.Visible = true
                else
                    obj.Name.Visible = false
                end

                -- Distance
                if ESPSettings.DistanceEnabled then
                    obj.Distance.Text = string.format("%.0f", distance).."m"
                    obj.Distance.Position = Vector2.new(screenHead.X, screenHead.Y + 20)
                    obj.Distance.Visible = true
                else
                    obj.Distance.Visible = false
                end

                
                if ESPSettings.HealthEnabled then
                    obj.Health.Text = string.format("[ %d HP ]", math.floor(humanoid.Health))
                    obj.Health.Position = Vector2.new(screenHead.X, screenHead.Y + 35)
                    obj.Health.Visible = true
                else
                    obj.Health.Visible = false
                end
            else
                updateBox3D(player, obj)
                obj.Name.Visible = false
                obj.Distance.Visible = false
                obj.Health.Visible = false
            end
        else
            updateBox3D(player, obj)
            obj.Name.Visible = false
            obj.Distance.Visible = false
            obj.Health.Visible = false
        end
    end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and ESPObjects[player] then
            local char = player.Character
            local esp = ESPObjects[player]
            if char and char:FindFirstChild("Head") and char:FindFirstChild("HumanoidRootPart") then
                local hrp = char.HumanoidRootPart
                local head = char.Head

                -- Skeleton rendering
                if ESPSettings.SkeletonEnabled then
                    local bones = {
                        {"Head", "UpperTorso"},
                        {"UpperTorso", "LowerTorso"},
                        {"UpperTorso", "LeftUpperArm"},
                        {"UpperTorso", "RightUpperArm"},
                        {"LeftUpperArm", "LeftLowerArm"},
                        {"RightUpperArm", "RightLowerArm"},
                        {"LeftLowerArm", "LeftHand"},
                        {"RightLowerArm", "RightHand"},
                        {"LowerTorso", "LeftUpperLeg"},
                        {"LowerTorso", "RightUpperLeg"},
                        {"LeftUpperLeg", "LeftLowerLeg"},
                        {"RightUpperLeg", "RightLowerLeg"},
                        {"LeftLowerLeg", "LeftFoot"},
                        {"RightLowerLeg", "RightFoot"},
                        {"UpperTorso", "Head"}
                    }

                    for i, pair in ipairs(bones) do
                        local part1 = char:FindFirstChild(pair[1])
                        local part2 = char:FindFirstChild(pair[2])
                        local line = esp.Skeleton[i]
                        if part1 and part2 then
                            local pos1, vis1 = Camera:WorldToViewportPoint(part1.Position)
                            local pos2, vis2 = Camera:WorldToViewportPoint(part2.Position)
                            if vis1 and vis2 then
                                line.From = Vector2.new(pos1.X, pos1.Y)
                                line.To = Vector2.new(pos2.X, pos2.Y)
                                line.Color = ESPSettings.SkeletonColor
                                line.Visible = true
                            else
                                line.Visible = false
                            end
                        else
                            line.Visible = false
                        end
                    end
                end
            else
                -- Hide all lines if no character
                if esp.Skeleton then
                    for _, line in pairs(esp.Skeleton) do
                        line.Visible = false
                    end
                end
            end
        end
    end
    
      if not droppedItems then return end
for item, obj in pairs(ItemESPObjects) do
    if item and item.Parent then
        if item.Name == "Money" then
            -- ‡∏ã‡πà‡∏≠‡∏ô‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏Å‡∏±‡∏ö‡∏ä‡∏∑‡πà‡∏≠
            for _, l in ipairs(obj.Box3D) do l.Visible = false end
            obj.Name.Visible = false
            continue -- ‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏õ item ‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
        end
            local basePart = item:IsA("BasePart") and item or item:FindFirstChildWhichIsA("BasePart")
            if not basePart then continue end

            local cf, size = basePart.CFrame, Vector3.new(1, 0.8, 1.5)
            local corners = {
        Vector3.new(-size.X, -size.Y, -size.Z) / 2,
        Vector3.new( size.X, -size.Y, -size.Z) / 2,
        Vector3.new( size.X,  size.Y, -size.Z) / 2,
        Vector3.new(-size.X,  size.Y, -size.Z) / 2,
        Vector3.new(-size.X, -size.Y,  size.Z) / 2,
        Vector3.new( size.X, -size.Y,  size.Z) / 2,
        Vector3.new( size.X,  size.Y,  size.Z) / 2,
        Vector3.new(-size.X,  size.Y,  size.Z) / 2,
            }

            local screenCorners, visCount = {}, 0
            for i, v in ipairs(corners) do
                local worldPos = (cf * CFrame.new(v)).Position
                local screenPos, onScreen = Camera:WorldToViewportPoint(worldPos)
                screenCorners[i] = Vector2.new(screenPos.X, screenPos.Y)
                if onScreen then visCount += 1 end
            end

            local edges = {
        {1,2},{2,3},{3,4},{4,1},
        {5,6},{6,7},{7,8},{8,5},
        {1,5},{2,6},{3,7},{4,8},
             }

            local lines = obj.Box3D
            if visCount == 8 and ESPSettings.EspViewitems then
                for i, e in ipairs(edges) do
                    local line = lines[i]
                    line.From = screenCorners[e[1]]
                    line.To = screenCorners[e[2]]
                    line.Visible = true
                end

                local screenPos, onScreen = Camera:WorldToViewportPoint(cf.Position)
                if onScreen and ESPSettings.EspViewitems then
                    obj.Name.Text = item.Name
                    obj.Name.Position = Vector2.new(screenPos.X, screenPos.Y - 10)
                    obj.Name.Visible = true
                else
                    obj.Name.Visible = false
                end
            else
                for _, l in ipairs(lines) do l.Visible = false end
                obj.Name.Visible = false
            end
        else
            removeItemESP(item)
        end
    end
    
end)

local highJumpEnabled = false
local jumpHeight = 30 

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ High Jump ‡πÉ‡∏´‡πâ‡∏ï‡∏±‡∏ß‡∏•‡∏∞‡∏Ñ‡∏£
local function setupHighJump(character)
    local humanoid = character:FindFirstChild("Humanoid")
    if humanoid then
        humanoid.JumpHeight = highJumpEnabled and jumpHeight or 7.2
    end
end





local longStrideEnabled = false
local strideLength = 5
local function setupLongStride(character)
    local humanoid = character:FindFirstChild("Humanoid")
    local root = character:FindFirstChild("HumanoidRootPart")

    if humanoid and root then
        -- ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Å‡πâ‡∏≤‡∏ß‡∏¢‡∏≤‡∏ß
        RunService.RenderStepped:Connect(function()
            if longStrideEnabled and humanoid.MoveDirection.Magnitude > 0 then
                root.CFrame = root.CFrame + humanoid.MoveDirection * strideLength * 0.05
            end
        end)
    end
end

if Client.Character then
    setupHighJump(Client.Character)
    setupLongStride(Client.Character)
end

-- ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏¥‡∏î‡πÉ‡∏´‡∏°‡πà
Client.CharacterAdded:Connect(function(character)
      setupHighJump(character)
    setupLongStride(character)
end)


c().EnabledSpeed = false
c().SpeedAmount = 24


func['EnabledSpeed'] = function()
	while task.wait() do
		if c().EnabledSpeed then 
			Humanoid:SetAttribute("TargetWalkSpeed", c().SpeedAmount)
            Humanoid.WalkSpeed = c().SpeedAmount
            ServerFunc:Action("set_sprinting_1", true)
        else 
            ServerFunc:Action("set_sprinting_1", false)
            Humanoid:SetAttribute("TargetWalkSpeed", 8)
			Humanoid.WalkSpeed = 8
		end
	end
end


func['EnabledSnap'] = function()
    local baseY = RootPart.Position.Y
    local lastOffset = c().YOffset or 1

    while c().EnabledSnap do
     task.wait()
        if Humanoid.Health > 0 then
            local currentOffset = c().YOffset or 1
            if currentOffset ~= lastOffset then
                lastOffset = currentOffset
            end
            local targetY = baseY - currentOffset
            local currentPos = RootPart.Position
            RootPart.CFrame = CFrame.new(currentPos.X, targetY, currentPos.Z) * RootPart.CFrame.Rotation
        end
    end
end

func['AutoPickItem'] = function()
    while waits() do 
        if c().AutoPickItem then 
            for i,v in get(droppedItems:GetChildren()) do 
                if not v:GetAttribute('Locked') then
                    local dist = ServerFunc:dist(v:FindFirstChild('PickUpZone'))
                    if dist < c().Stud_PickItem then 
                        Net.get("pickup_dropped_item",v)
                    end 
                end
            end
        end
    end
end

local droppedItems = workspace:WaitForChild("DroppedItems")
local pickUpZoneEnabled = false -- ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ toggle

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î PickUpZone
local function resizePickUpZone(model)
    if model:IsA("Model") then
        for _, child in ipairs(model:GetChildren()) do
            if child:IsA("Part") and child.Name == "PickUpZone" then
                child.Size = pickUpZoneEnabled and Vector3.new(15, 15, 15) or Vector3.new(5,3,3)
            end
        end
    end
end

-- ‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î PickUpZone ‡∏Ç‡∏≠‡∏á‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
local function resizeAll()
    for _, model in ipairs(droppedItems:GetChildren()) do
        resizePickUpZone(model)
    end
end

-- ‡∏ü‡∏±‡∏á‡πÄ‡∏´‡∏ï‡∏∏‡∏Å‡∏≤‡∏£‡∏ì‡πå‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡πÇ‡∏°‡πÄ‡∏î‡∏•‡πÉ‡∏´‡∏°‡πà‡∏ñ‡∏π‡∏Å‡πÄ‡∏û‡∏¥‡πà‡∏°
droppedItems.ChildAdded:Connect(function(newModel)
    resizePickUpZone(newModel)
end)







do
local Main = Window:Tab({
        Title = "Main",
        Icon = "arrow-left-right"
    })
    
    
    
    local Aim = Main:Toggle({
      Title = "SilentAim",
      Value = false,
      Callback = function(state)
        SilentAim = state
      end
    })
    
    local FovEn = Main:Toggle({
      Title = "Fov Enabled",
      Value = false,
      Callback = function(state)
        fov.Visible = state
      end
    })
    
    

    local FovSize = Main:Slider({
        Title = "Fov Radius",
        Value = { Min = 10, Max = 600, Default = 100 },
        Callback = function(value)
            getgenv().Radius = tonumber(value)
        end
    })
    
    FovSize:SetMin(10)
    FovSize:SetMax(600)
    FovSize:Set(100)
    
--[[ local antiAim = Main:Toggle({
    Title = "Anti Aim",
   -Value = false,
   Callback = function(state)
        getgenv().Antiaim = state
        if state then
            startAntiAim()
        else
            stopAntiAim()
        end
    end
})
--]]

Client.CharacterAdded:Connect(function(char)
    character = char
    humanoid = char:WaitForChild("Humanoid")

    if getgenv().Antiaim then
        startAntiAim()
    end
end)


local antiAim = Main:Toggle({
    Title = "Anti Aim",
    Value = false,
    Desc = "KeyBind E",
    Callback = function(state)
        getgenv().DesyncEnabled = state
    end
})


    Main:Space()
    
    local Snap = Main:Toggle({
      Title = "Snap",
      Value = false,
      Callback = function(state)
        c().EnabledSnap = state
        task.spawn(func['EnabledSnap'])
      end
    })
    
    local Yoffset = Main:Slider({
    Title = "Y Offset",
    Value = { Min = 1, Max = 100.0, Default = 30 },
    Callback = function(value)
        c().YOffset = tonumber(value)
    end
    })
    
    Yoffset:SetMin(1)
    Yoffset:SetMax(100)
    Yoffset:Set(10)
    
        
    

    
end


do
    local Character = Window:Tab({
        Title = "Character",
        Icon = "mouse-pointer-click",
    })
    

local antiRagdoll = Character:Toggle({
    Title = "Anti Ragdoll",
    Value = false, -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏õ‡∏¥‡∏î
    Callback = function(state)
        AntiRagdoll = state
        
   if  AntiRagdoll then
    task.spawn(function()
	while true do
		pcall(function()
			Net.send('end_ragdoll_early')
		end)
		task.wait(0.25) -- ‡∏´‡∏ô‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤ 0.1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ (‡∏õ‡∏£‡∏±‡∏ö‡πÑ‡∏î‡πâ)
	  end
   end)
     print("‡∏ó‡∏≥‡∏á‡∏≤‡∏ô")
   else
     print("‡πÑ‡∏°‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô")
end
    end
})

    local antikilll = Character:Toggle({
    Title = "Anti Kill",
    Value = false,
    Callback = function(state)
        antiKillEnabled = state
    end
})



-- Toggle ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Long Stride
local longStrideToggle = Character:Toggle({
    Title = "WalkSpeed",
    Value = false, -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏õ‡∏¥‡∏î
    Callback = function(state)
        longStrideEnabled = state

    end
})

local StrideSlider = Character:Slider({
    Title = "Stride Length",
    Value = { Min = 1, Max = 5, Default = 3 },
    Callback = function(value)
      strideLength = value
    end
 })
 
    StrideSlider:SetMin(1)
    StrideSlider:SetMax(5)
    StrideSlider:Set(3)
    
    local InfinityStamina = Character:Toggle({
    Title = "Infinity Stamina",
    Value = false,
    Callback = function(state)
        c().EnabledSpeed = state
        if state then
            task.spawn(func['EnabledSpeed'])
        else
            c().EnabledSpeed = false
        end
    end
})



local jumpToggle = Character:Toggle({
    Title = "High Jump",
    Value = false, -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏õ‡∏¥‡∏î
    Callback = function(state)
        highJumpEnabled = state

        -- ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤ JumpHeight ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
        if pls.Character and pls.Character:FindFirstChild("Humanoid") then
            pls.Character.Humanoid.JumpHeight = state and jumpHeight or 7.2
        end

        
    end
})
   
   local AutoPickItem = Character:Toggle({
    Title = "PickItem",
    Value = false, -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏õ‡∏¥‡∏î
    Callback = function(state)
    c().AutoPickItem = state
    pickUpZoneEnabled = state
        resizeAll() -- ‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
    end
})

    

    
end

do
    local Esp = Window:Tab({
        Title = "ESP",
        Icon = "text-cursor-input",
    })
    local espbox1 = Esp:Toggle({
    Title = "Esp 3DBox",
    Value = false, -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏õ‡∏¥‡∏î
    Callback = function(state)
         ESPSettings.Box3DEnabled = state
    end
    })
    
    local espSkeleton = Esp:Toggle({
    Title = "Esp Skeleton",
    Value = false, -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏õ‡∏¥‡∏î
    Callback = function(state)
         ESPSettings.SkeletonEnabled = state
    end
    })
    
    
    local espbox2 = Esp:Toggle({
    Title = "Esp Name",
    Value = false, -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏õ‡∏¥‡∏î
    Callback = function(state)
         ESPSettings.NameEnabled = state
    end
    })
    
    
    local espbox3 = Esp:Toggle({
    Title = "Esp Hp",
    Value = false, -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏õ‡∏¥‡∏î
    Callback = function(state)
         ESPSettings.HealthEnabled = state
    end
     })
    
    local espbox9 = Esp:Toggle({
    Title = "Esp Viewer Items 3D Box",
    Value = false, -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏õ‡∏¥‡∏î
    Callback = function(state)
         ESPSettings.EspViewitems = state
    end
     })
     
    local EspInventoryViewer = Esp:Toggle({
    Title = "Esp InventoryViewer",
    Value = false,
    Callback = function(state)
        settings.EnabledInventoryViewer = state
    end
    })
    
    
    
    
end
