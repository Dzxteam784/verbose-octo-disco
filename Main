local WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/main/dist/main.lua"))()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Data = require(ReplicatedStorage.Modules.Core.Data)
local pls = game.Players.LocalPlayer
local highJumpEnabled = false -- ค่าเริ่มต้นปิด




-- */  Window  /* --
local Window = WindUI:CreateWindow({
    Title = "DZHUB  | v-1.0 Test",
    Author = "by danzaza ",
    NewElements = true,
    
    HideSearchBar = false,
    
    OpenButton = {
        Title = "Open DZHUB UI", -- can be changed
        CornerRadius = UDim.new(1,0), -- fully rounded
        StrokeThickness = 3, -- removing outline
        Enabled = true, -- enable or disable openbutton
        Draggable = true,
        OnlyMobile = false,
        
        Color = ColorSequence.new( -- gradient
            Color3.fromHex("#30FF6A"), 
            Color3.fromHex("#e7ff2f")
        )
    }
})

--Window:SetTitle(Window.Title .. " | " .. WindUI.Version)


-- */  Configuring OpenButton  /* --
--[[ moved to :CreateWindow(...)
Window:EditOpenButton({
    Title = "Open DZHUB UI", -- can be changed
    CornerRadius = UDim.new(1,0), -- fully rounded
    StrokeThickness = 3, -- removing outline
    Enabled = true, -- enable or disable openbutton
    Draggable = true,
    OnlyMobile = false,
    
    Color = ColorSequence.new( -- gradient
        Color3.fromHex("#30FF6A"), 
        Color3.fromHex("#e7ff2f")
    )
    
    -- Icon = "monitor",
})
--]]


-- */ Other Functions /* --
local function parseJSON(luau_table, indent, level, visited)
    indent = indent or 2
    level = level or 0
    visited = visited or {}
    
    local currentIndent = string.rep(" ", level * indent)
    local nextIndent = string.rep(" ", (level + 1) * indent)
    
    if luau_table == nil then
        return "null"
    end
    
    local dataType = type(luau_table)
    
    if dataType == "table" then
        if visited[luau_table] then
            return "\"[Circular Reference]\""
        end
        
        visited[luau_table] = true
        
        local isArray = true
        local maxIndex = 0
        
        for k, _ in pairs(luau_table) do
            if type(k) == "number" and k > maxIndex then
                maxIndex = k
            end
            if type(k) ~= "number" or k <= 0 or math.floor(k) ~= k then
                isArray = false
                break
            end
        end
        
        local count = 0
        for _ in pairs(luau_table) do
            count = count + 1
        end
        if count ~= maxIndex and isArray then
            isArray = false
        end
        
        if count == 0 then
            return "{}"
        end
        
        if isArray then
            if count == 0 then
                return "[]"
            end
            
            local result = "[\n"
            
            for i = 1, maxIndex do
                result = result .. nextIndent .. parseJSON(luau_table[i], indent, level + 1, visited)
                if i < maxIndex then
                    result = result .. ","
                end
                result = result .. "\n"
            end
            
            result = result .. currentIndent .. "]"
            return result
        else
            local result = "{\n"
            local first = true
            
            local keys = {}
            for k in pairs(luau_table) do
                table.insert(keys, k)
            end
            table.sort(keys, function(a, b)
                if type(a) == type(b) then
                    return tostring(a) < tostring(b)
                else
                    return type(a) < type(b)
                end
            end)
            
            for _, k in ipairs(keys) do
                local v = luau_table[k]
                if not first then
                    result = result .. ",\n"
                else
                    first = false
                end
                
                if type(k) == "string" then
                    result = result .. nextIndent .. "\"" .. k .. "\": "
                else
                    result = result .. nextIndent .. "\"" .. tostring(k) .. "\": "
                end
                
                result = result .. parseJSON(v, indent, level + 1, visited)
            end
            
            result = result .. "\n" .. currentIndent .. "}"
            return result
        end
    elseif dataType == "string" then
        local escaped = luau_table:gsub("\\", "\\\\")
        escaped = escaped:gsub("\"", "\\\"")
        escaped = escaped:gsub("\n", "\\n")
        escaped = escaped:gsub("\r", "\\r")
        escaped = escaped:gsub("\t", "\\t")
        
        return "\"" .. escaped .. "\""
    elseif dataType == "number" then
        return tostring(luau_table)
    elseif dataType == "boolean" then
        return luau_table and "true" or "false"
    elseif dataType == "function" then
        return "\"function\""
    else
        return "\"" .. dataType .. "\""
    end
end

local function tableToClipboard(luau_table, indent)
    indent = indent or 4
    local jsonString = parseJSON(luau_table, indent)
    setclipboard(jsonString)
    return jsonString
end













local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local SendRemote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Send")
local Camera = workspace.CurrentCamera

local fov = 200


-- กำหนดตำแหน่ง GUI ที่ต้องการ
local guiPosition = LocalPlayer.PlayerGui.SelectPlayer.ChoosePlayerHolder.AbsolutePosition
local guiSize = LocalPlayer.PlayerGui.SelectPlayer.ChoosePlayerHolder.AbsoluteSize

-- FOV Circle
local fovCircle = Drawing.new("Circle")
fovCircle.Radius = fov
fovCircle.Color = Color3.new(0,1,0)
fovCircle.Thickness = 2
fovCircle.Filled = false
fovCircle.Visible = false
fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

-- หาเป้าหมายใกล้ที่สุดใน FOV
local function getClosestTargetInFOV()
    local closestDistance = math.huge
    local closestHumanoidPart = nil

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local head = player.Character:FindFirstChild("Head")
            if head then
                local screenPos, onScreen = Camera:WorldToViewportPoint(head.Position)
                if onScreen then
                    local distToCenter = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)).Magnitude
                    if distToCenter <= fovCircle.Radius and distToCenter < closestDistance then
                        closestDistance = distToCenter
                        closestHumanoidPart = head
                    end
                end
            end
        end
    end

    return closestHumanoidPart
end

-- ESP Line
local line = Drawing.new("Line")
line.Color = Color3.new(1,0,0)
line.Thickness = 2
line.Transparency = 1

-- สร้าง Tracer
local function createTracer(startPos, endPos, hitPlayer)
    local tracer = Instance.new("Part")
    tracer.Anchored = true
    tracer.CanCollide = false
    tracer.Material = Enum.Material.Neon
    tracer.Color = hitPlayer and Color3.new(1,0,0) or Color3.new(1,1,0)
    tracer.Size = Vector3.new(0.1, 0.1, (startPos - endPos).Magnitude)
    tracer.CFrame = CFrame.new((startPos + endPos)/2, endPos)
    tracer.Parent = workspace
    game:GetService("Debris"):AddItem(tracer, 1.5)
end

-- Update FOV + ESP
RunService.RenderStepped:Connect(function()
    fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

    -- อัพเดทตำแหน่ง GUI
    guiPosition = LocalPlayer.PlayerGui.SelectPlayer.ChoosePlayerHolder.AbsolutePosition
    guiSize = LocalPlayer.PlayerGui.SelectPlayer.ChoosePlayerHolder.AbsoluteSize
    
    -- คำนวณจุดกึ่งกลางของ GUI และปรับให้ต่ำลง
    local guiCenter = Vector2.new(
        guiPosition.X + guiSize.X / 2,
        guiPosition.Y + guiSize.Y + 58  -- เพิ่มค่า Y ให้ต่ำลง 50 pixels จากขอบล่างของ GUI
    )

    local target = getClosestTargetInFOV()
    if target then
        local endPos = Camera:WorldToViewportPoint(target.Position)

        -- เริ่มจาก GUI ไปหาศัตรู
        line.From = guiCenter
        line.To = Vector2.new(endPos.X, endPos.Y)
        line.Visible = true
    else
        line.Visible = false
    end
end)

-- ฟังก์ชันคำนวณตำแหน่งดักหน้า
local function getPredictedPosition(target)
    local root = target.Parent:FindFirstChild("HumanoidRootPart")
    if not root then return target.Position end

    local velocity = root.Velocity or Vector3.new(0,0,0)
    local ping = 0.25 -- กำหนดเวลา lag/ping (ปรับตามความจริง)
    
    -- ตำแหน่งที่คาดการณ์อนาคต
    local predictedPos = target.Position + velocity * ping
    return predictedPos
end

-- Hook FireServer ปรับให้ยิงดักหน้า
local oldSendFire
oldSendFire = hookfunction(SendRemote.FireServer, function(self, ...)
    local args = {...}

    if type(args[2]) == "string" and args[2]:lower():find("shoot") then
        local targetHead = getClosestTargetInFOV()
        if targetHead and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local predictedPos = getPredictedPosition(targetHead)

            -- ยิงไปตำแหน่งที่คาดการณ์
            args[4] = CFrame.new(math.huge, math.huge, math.huge) 
            args[5] = {
                {
                    {
                        Instance = targetHead,
                        Position = predictedPos,
                        Normal = (predictedPos - LocalPlayer.Character.Head.Position).Unit,
                        Material = Enum.Material.Plastic,
                        Distance = (predictedPos - LocalPlayer.Character.Head.Position).Magnitude
                    }
                }
            }

            -- Tracer (เริ่มจากผู้เล่นไปหาตำแหน่งคาดการณ์)
            createTracer(LocalPlayer.Character.HumanoidRootPart.Position, predictedPos, true)
        end
    end

    return oldSendFire(self, unpack(args))
end)





local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- ESP Settings
local ESPSettings = {
    Box3DEnabled = true, -- ✅ ใช้ Box 3D แทน 2D
    SkeletonEnabled = true,
    NameEnabled = true,
    DistanceEnabled = true,
    HealthEnabled = true, -- ✅ แสดงเลือด
    BoxColor = Color3.fromRGB(255,255,255),
    LockColor = Color3.fromRGB(255,0,0),
    NameColor = Color3.fromRGB(255,255,255),
    HealthColor = Color3.fromRGB(0,255,0)
}

-- Store Drawing objects
local ESPObjects = {}

-- Function to remove ESP when player leaves
local function removeESP(player)
    if ESPObjects[player] then
        for _, obj in pairs(ESPObjects[player]) do
            if typeof(obj) == "table" then
                for _, v in ipairs(obj) do v:Remove() end
            else
                obj:Remove()
            end
        end
        ESPObjects[player] = nil
    end
end

-- Function to create ESP for a player
local function createESP(player)
    -- Box 3D (12 เส้น)
    local box3D = {}
    for i = 1, 12 do
        local line = Drawing.new("Line")
        line.Thickness = 1
        line.Color = ESPSettings.BoxColor
        line.Visible = false
        table.insert(box3D, line)
    end

    -- Name
    local nameText = Drawing.new("Text")
    nameText.Size = 10
    nameText.Color = ESPSettings.NameColor
    nameText.Center = true
    nameText.Outline = true
    nameText.Visible = false

    -- Distance
    local distanceText = Drawing.new("Text")
    distanceText.Size = 7
    distanceText.Center = true
    distanceText.Outline = true
    distanceText.Visible = false

    -- Health text
    local healthText = Drawing.new("Text")
    healthText.Size = 8
    healthText.Color = ESPSettings.HealthColor
    healthText.Center = true
    healthText.Outline = true
    healthText.Visible = false

    ESPObjects[player] = {
        Box3D = box3D,
        Name = nameText,
        Distance = distanceText,
        Health = healthText
    }
end

-- Create ESP for existing players
for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        createESP(player)
    end
end

-- Create ESP for new players
Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        createESP(player)
    end
end)

-- Remove ESP when player leaves
Players.PlayerRemoving:Connect(function(player)
    removeESP(player)
end)

-- Function to get closest target
local function getClosestTargetInFOV()
    local closestDistance = math.huge
    local closestTarget = nil
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local part = player.Character:FindFirstChild("Head") or player.Character:FindFirstChild("HumanoidRootPart")
            if part then
                local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local distToCenter = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)).Magnitude
                    if distToCenter < closestDistance then
                        closestDistance = distToCenter
                        closestTarget = part
                    end
                end
            end
        end
    end
    return closestTarget
end

-- 🔹 อัปเดต Box 3D
local function updateBox3D(player, obj)
    local char = player.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return end

    local hrp = char.HumanoidRootPart
    local cf, size = hrp.CFrame, Vector3.new(4, 7, 4)

    local corners = {
        Vector3.new(-size.X, -size.Y, -size.Z) / 2,
        Vector3.new( size.X, -size.Y, -size.Z) / 2,
        Vector3.new( size.X,  size.Y, -size.Z) / 2,
        Vector3.new(-size.X,  size.Y, -size.Z) / 2,
        Vector3.new(-size.X, -size.Y,  size.Z) / 2,
        Vector3.new( size.X, -size.Y,  size.Z) / 2,
        Vector3.new( size.X,  size.Y,  size.Z) / 2,
        Vector3.new(-size.X,  size.Y,  size.Z) / 2,
    }

    local screenCorners, visCount = {}, 0
    for i, v in ipairs(corners) do
        local worldPos = (cf * CFrame.new(v)).Position
        local screenPos, onScreen = Camera:WorldToViewportPoint(worldPos)
        screenCorners[i] = Vector2.new(screenPos.X, screenPos.Y)
        if onScreen then visCount += 1 end
    end

    local edges = {
        {1,2},{2,3},{3,4},{4,1},
        {5,6},{6,7},{7,8},{8,5},
        {1,5},{2,6},{3,7},{4,8},
    }

    local lines = obj.Box3D
    if ESPSettings.Box3DEnabled and visCount == 8 then
        local target = getClosestTargetInFOV()
        local color = (target and target.Parent == char) and ESPSettings.LockColor or ESPSettings.BoxColor

        for i, e in ipairs(edges) do
            local line = lines[i]
            line.From = screenCorners[e[1]]
            line.To   = screenCorners[e[2]]
            line.Color = color
            line.Visible = true
        end
    else
        for _, l in ipairs(lines) do l.Visible = false end
    end
end

-- Update ESP
RunService.RenderStepped:Connect(function()
    for player, obj in pairs(ESPObjects) do
        local char = player.Character
        if char and char:FindFirstChild("HumanoidRootPart") and char:FindFirstChild("Humanoid") then
            local root = char.HumanoidRootPart
            local head = char:FindFirstChild("Head")
            local humanoid = char.Humanoid

            local screenHead, headOnScreen = Camera:WorldToViewportPoint(head.Position)
            local distance = (root.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude

            if headOnScreen then
                -- ✅ Box 3D
                updateBox3D(player, obj)

                -- Name
                if ESPSettings.NameEnabled then
                    obj.Name.Text = player.Name
                    obj.Name.Position = Vector2.new(screenHead.X, screenHead.Y - 10)
                    obj.Name.Visible = true
                else
                    obj.Name.Visible = false
                end

                -- Distance
                if ESPSettings.DistanceEnabled then
                    obj.Distance.Text = string.format("%.0f", distance).."m"
                    obj.Distance.Position = Vector2.new(screenHead.X, screenHead.Y + 20)
                    obj.Distance.Visible = true
                else
                    obj.Distance.Visible = false
                end

                -- ✅ Health
                if ESPSettings.HealthEnabled then
                    obj.Health.Text = string.format("%d HP", math.floor(humanoid.Health))
                    obj.Health.Position = Vector2.new(screenHead.X, screenHead.Y + 35)
                    obj.Health.Visible = true
                else
                    obj.Health.Visible = false
                end
            else
                updateBox3D(player, obj)
                obj.Name.Visible = false
                obj.Distance.Visible = false
                obj.Health.Visible = false
            end
        else
            updateBox3D(player, obj)
            obj.Name.Visible = false
            obj.Distance.Visible = false
            obj.Health.Visible = false
        end
    end
end)





local plr = game:GetService("Players").LocalPlayer

local DROP_Y = -100
local HEALTH_MIN = 20
local HEALTH_RECOVER = 30

local isDropping = false 
local antiKillEnabled = true -- เพิ่มตัวแปรเชื่อมกับ Toggle

-- ฟังก์ชันตั้งค่า character
local function setupCharacter(char)
    local humanoid = char:WaitForChild("Humanoid")
    local rootPart = char:WaitForChild("HumanoidRootPart")

    local function startDrop()
        if not antiKillEnabled then return end
        if isDropping then return end
        isDropping = true

        local fixedPos = rootPart.Position  
        fixedPos = Vector3.new(fixedPos.X, fixedPos.Y + DROP_Y, fixedPos.Z)  

        while isDropping do  
            if humanoid.Health >= HEALTH_RECOVER or humanoid.Health <= 0 then
                isDropping = false
                break
            end  
            rootPart.CFrame = CFrame.new(fixedPos)  
            task.wait(0.001)
        end
    end

    humanoid.HealthChanged:Connect(function(hp)
        if hp < HEALTH_MIN and hp > 0 then
            startDrop()
        end
    end)
end

-- เรียกตอนเริ่มเกม
if plr.Character then
    setupCharacter(plr.Character)
end

-- เรียกใหม่ทุกครั้งที่ respawn
plr.CharacterAdded:Connect(setupCharacter)














-- */  Toggle Tab  /* --
do
    local ToggleTab = Window:Tab({
        Title = "Main",
        Icon = "arrow-left-right"
    })
    



   local moneyButton = ToggleTab:Button({
    Title = "Bank 🏛",
    Desc = "Loading...",
    })

    local function updateMoney(newMoney)
    local bank = 0
    if newMoney and newMoney.bank then
        bank = newMoney.bank
    elseif Data.money and Data.money.bank then
        bank = Data.money.bank
    end
    
    if moneyButton.SetDesc then
        moneyButton:SetDesc(" $" .. tostring(bank))
      end
   end

   updateMoney(Data.money)
    Data.hook("money", function(newMoney)
    updateMoney(newMoney)
   end)

    ToggleTab:Space()
    
    local moneyhand =ToggleTab:Button({
     Title = "Hand 💵",
     Desc = "Loading..."
    
    })
    
  local function updateMoneyhand(handnew)
  local hand = 0 
    if handnew and handnew.hand then 
      hand = handnew.hand
    elseif Data.money and Data.money.hand then 
      hand = Data.money.hand
    end
    
    if moneyhand.SetDesc then 
      moneyhand:SetDesc(" $" .. tostring(hand))
    end
  end
  
  updateMoneyhand(Data.money)
    
  if Data.hook then
    Data.hook("money", function(newMoney)
        updateMoneyhand(newMoney)
    end)
  end
  
  ToggleTab:Space()
  
  local toggleState = false
    local featureToggle = ToggleTab:Toggle({
      Title = "Show FOV Circle",
      Value = false,
      Callback = function(state)
        toggleState = state
        fovCircle.Visible = state
        
        WindUI:Notify({
            Title = "FOV Circle",
            Content = state and "Enabled" or "Disabled",
            Icon = state and "check" or "x",
            Duration = 2
        })
      end
    })
    
 
  
    
end --end tab main


-- */  Button Tab  /* --
do
    local Character = Window:Tab({
        Title = "Character",
        Icon = "mouse-pointer-click",
    })
    

local highJumpEnabled = false
local jumpHeight = 30 -- ความสูงของกระโดด


-- ฟังก์ชันตั้งค่า High Jump ให้ตัวละคร
local function setupHighJump(character)
    local humanoid = character:FindFirstChild("Humanoid")
    if humanoid then
        humanoid.JumpHeight = highJumpEnabled and jumpHeight or 7.2
    end
end

-- ถ้ามีตัวละครแล้ว
if pls.Character then
    setupHighJump(pls.Character)
end

-- ตั้งค่าใหม่ทุกครั้งที่เกิดใหม่
pls.CharacterAdded:Connect(function(character)
    setupHighJump(character)
end)

-- Toggle สำหรับ High Jump
local jumpToggle = Character:Toggle({
    Title = "High Jump",
    Value = false, -- เริ่มต้นปิด
    Callback = function(state)
        highJumpEnabled = state

        -- ปรับค่า JumpHeight ทันที
        if pls.Character and pls.Character:FindFirstChild("Humanoid") then
            pls.Character.Humanoid.JumpHeight = state and jumpHeight or 7.2
        end

        WindUI:Notify({
            Title = "High Jump",
            Content = state and "Enabled" or "Disabled",
            Icon = state and "check" or "x",
            Duration = 2
        })
    end
})


Character:Space()

-- ตัวแปรเก็บสถานะ
local longStrideEnabled = false
local strideLength = 3.5 -- ปรับความยาวก้าว
local RunService = game:GetService("RunService")
local player = pls -- สมมติ pls = LocalPlayer

-- ฟังก์ชันตั้งค่าก้าวยาวให้ตัวละคร
local function setupLongStride(character)
    local humanoid = character:FindFirstChild("Humanoid")
    local root = character:FindFirstChild("HumanoidRootPart")

    if humanoid and root then
        -- เชื่อมฟังก์ชันก้าวยาว
        RunService.RenderStepped:Connect(function()
            if longStrideEnabled and humanoid.MoveDirection.Magnitude > 0 then
                root.CFrame = root.CFrame + humanoid.MoveDirection * strideLength * 0.05
            end
        end)
    end
end

-- ถ้ามีตัวละครแล้ว
if player.Character then
    setupLongStride(player.Character)
end

-- ตั้งค่าใหม่ทุกครั้งที่เกิดใหม่
player.CharacterAdded:Connect(function(character)
    setupLongStride(character)
end)

-- Toggle สำหรับ Long Stride
local longStrideToggle = Character:Toggle({
    Title = "WalkSpeed",
    Value = false, -- เริ่มต้นปิด
    Callback = function(state)
        longStrideEnabled = state

        WindUI:Notify({
            Title = "Long Stride",
            Content = state and "Enabled" or "Disabled",
            Icon = state and "check" or "x",
            Duration = 2
        })
    end
})
    
    
Character:Space()
    
    
    
end


-- */  Input Tab  /* --
do
    local InputTab = Window:Tab({
        Title = "Server",
        Icon = "text-cursor-input",
    })
    
    
    InputTab:Input({
        Title = "Input",
        Icon = "mouse"
    })
    
    
end




